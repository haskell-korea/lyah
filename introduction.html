<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0060)http://learnyouahaskell.com/introduction#about-this-tutorial -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Introduction - Learn You a Haskell for Great Good!</title>

    <!--<base href="http://haskell.or.kr/">--><base href=".">
    <style type="text/css">
      @import url('reset.css');
      @import url('style.css');
    </style>
    <link rel="shortcut icon" href="http://haskell.or.kr/favicon.png" type="image/png">
    <link rel="next" href="http://haskell.or.kr/starting-out">
    <link type="text/css" rel="stylesheet" href="./files/SyntaxHighlighter.css">
    <body class="introcontent">
      <div class="bgwrapper">
	<div id="content">
          <div class="footdiv" style="margin-bottom:25px;">
            <ul>
              <li style="text-align:left">
              </li>
              <li style="text-align:center">
                <a href="http://haskell.or.kr/chapters.html">Table of contents</a>
              </li>
              <li style="text-align:right">
                <a href="http://haskell.or.kr/starting-out.html" class="nxtlink">Starting Out</a>
              </li>
            </ul>
          </div>
          <h1>소개합니다</h1> 
	  <a name="about-this-tutorial"></a>
	  <h2>이 책에 대하여</h2>
	  <p>
	    <em>Learn You a Haskell for Great Good</em>에 오신 것을 환영합니다!
	    이 책을 읽는다는 건 하스켈을 배울 의향이 생기셨다는 뜻이겠지요. 잘 오셨습니다. 그러나 잠시, 이 책에 대해 조금만 소개하기로 하겠습니다.
	  </p>
	  <p>
	    이 책을 쓰게 된 것은 하스켈에 대한 저의 지식을 더 공고히 하고 싶었고, 또 저의 관점으로 하스켈을 처음 접하는 사람에게 도움을 줄 수 있으리라 생각했기 때문입니다. 인터넷엔 이미 꽤 많은 하스켈 튜토리얼들이 있습니다. 하지만 제가 처음 하스켈을 배울 때는 한 가지 자료만 보고 공부한 것이 아니라, 다양한 여러 튜토리얼과 글들을 읽어야 했습니다. 왜냐하면 한 가지 개념에 대해 그들이 서로 다르게 설명하는 것처럼 보였기 때문이지요. 여러 자료들을 섭렵하고 나서야, 저는 비로소 그 개념들을 이해할 수 있었습니다. 그래서 이 책을 쓰는 것은 당신이 하스켈을 배울 때 유용한 자료를 하나 추가하는 것이라고 할 수도 있습니다.
	  </p>
	  <img src="./files/bird.png" alt="bird" class="left" width="230" height="192">
	  <p>
	    이 책은 기존의 C, C++, Java, Python과 같은 명령형 프로그래밍 언어(imperative programming language)를 사용해 본 경험은 있지만 하스켈, ML, Ocaml과 같은 함수형 언어(functional language)는 접해본 적이 없는 사람들을 대상으로 작성된 것입니다. 하지만 당신처럼 똑똑한 사람이라면 대단한 프로그래밍 경험이 없어도, 이 책의 내용을 배우는데 큰 어려움은 겪지 않으리라 생각합니다.
	  </p>
	  <p>
	    만약 어떤 문제에 막혔다고 생각되면 freenode IRC의 #haskell 채널에 질문하세요. 이 곳의 사람들은 대단히 점잖은 사람들이고, 초심자들을 이해하며 인내심이 많은 사람들입니다.
	  </p>
	  <p>
	    저는 지금처럼 하스켈에 익숙해지기 전까지 2번쯤 하스켈을 배우는 데 실패했었습니다. 하스켈의 모든 개념이 제게는 너무 이상해 보였고, 이해도 되지 않았기 때문입니다. 하지만 한 순간 돌연 개념들이 이해되는 순간이 있었고, 그 이후로는 모든 것들이 아주 쉽게 이해되었습니다. 어쨌든 제가 하고 싶은 말은, 하스켈은 대단한 언어이고, 프로그래밍에 관심있는 사람이라면 처음에는 조금 이상해 보이더라도 하스켈을 꼭 배워야 한다는 말입니다. 하스켈을 배우는 일은  프로그래밍을 처음으로 배우는 것과 비슷합니다 - 아주 재미있지요! 하스켈을 배우려면 기존과는 다르게 생각하는 법을 배워야 합니다.
	  </p>

	  <a name="so-whats-haskell"></a><h2>하스켈이 뭘까요?</h2>
	  <p>
	    <img src="./files/fx.png" alt="fx" class="right" width="150" height="146">
	    하스켈은 <em>&quot;순수한&quot; 함수형 프로그래밍 언어입니다. </em> 명령형 언어에서는 컴퓨터에게 일련의 작업들을 전달하고 실행 시켜서 일을 처리합니다. 이 작업들은 실행되면서 상태를 변경합니다. 예를 들어, 변수 <span class="fixed">a</span>에 5를 넣어놓고 어떤 일을 한 뒤, <span class="fixed">a</span>의 값을 변경하는 식입니다. 그리고 변경된 <span class="fixed">a</span>의 값에 의해 프로그램의 다음 동작이 바뀌는 식으로 어떤 행동을 여러번 하는 제어 흐름 구조를 가지게 됩니다. 반면 순수 함수형 언어인 하스켈에서는 컴퓨터에게 일을 어떻게 할 것인지가 아니라 <i>무엇을 하려는 것</i>인지 적습니다. (역자 주 - 명령형 언어에서는 변수와 for 문등을 가지고 팩토리얼값을 계산하는 방법을 서술하는 데 비해) 하스켈에서는 어떤 자연수의 팩토리얼은 1부터 그 수 사이의 모든 자연수들의 곱이라는 것을 정의하게 되고, 어떤 숫자 리스트의 총합은 그 리스트에 있는 모든 숫자들의 총합이고... 이런 식입니다. 이것들을 하스켈 문법에 맞춰 함수의 형태로 표현하게 됩니다. 또 하스켈에는 값을 변경할 수 있는 변수가 존재하지 않습니다. 한 번 <span class="fixed">a</span>를 5라고 선언하면 나중에 바꿀 수 없습니다. 말을 바꾸는 건 정직하지 못하니까요. 그래서 순수 함수형 언어에서는 함수가 side-effect를 갖지 않습니다. 함수가 할 수 있는 일은 그저 뭔가 계산하고 그 결과를 반환하는 것 뿐입니다. 처음엔 너무 과한 제약이 아닌가 생각할 수도 있지만, 덕분에 하스켈은 아주 좋은 특징을 갖게 되었습니다. 함수가 같은 인자로 여러번 호출되면 매번 같은 결과를 반환하게 되는 속성입니다. 이런 속성을 referential transparency라고 부르는데, 이 속성 덕분에 컴파일러가 프로그램의 동작을 더 잘 분석할 수 있고, 여러분이 프로그래밍 할 때 함수가 제대로 작성되었는지 확인하거나 (혹은 증명하는) 일을 가능하게 합니다. 또 간단한 함수 여러개를 붙여 복잡한 함수를 만들 때도 이런 속성이 유용합니다.
	  </p>
	  <p>
	    <img src="./files/lazy.png" class="right" alt="lazy" width="240" height="209">
	    하스켈은 <em>게으른(lazy)</em> 언어입니다. 이게 무슨 뜻인가 하면, 하스켈은 함수의 계산 결과 값이 실제로 사용자에게 보여져야 하는 등 특별한 상황이 되지 않으면 함수를 실제로 실행하거나 무언가를 계산하지 않는다는 뜻입니다. 이 특징은 앞서 말씀드린 referential transparency와 아주 궁합이 잘 맞습니다. 또 하스켈의 이러한 특징들 덕분에 여러분은 프로그램을 <em>데이터의 변화(transformations on data)</em> 과정으로 이해할 수 있게 됩니다. 게다가 무한한 자료 구조와 같은 멋진 일까지 가능해집니다. <span class="fixed">xs = [1,2,3,4,5,6,7,8]</span> 같은 immutable한 숫자 리스트가 있고, 숫자 리스트를 하나 받아서 그 안의 값을 각각 2배한 새로운 숫자 리스트를 반환하는 <span class="fixed">doubleMe</span> 라는 함수가 있다고 합시다. 만약 게으르지 않은 언어에서 숫자 리스트에 8을 곱하려고 <span class="fixed">doubleMe(doubleMe(doubleMe(xs)))</span> 와 같이 호출한다면 어떻게 될까요? 우선 리스트 <span class="fixed">xs</span>가 <span class="fixed">doubleMe</span> 함수에 전달되어 리스트 멤버들에 접근해서 각 값을 2배한 새로운 리스트가 반환되고, 이 과정이 두 번 더 반복될 것입니다. 반면 게으른 언어에서는, 계산 결과를 화면에 출력하거나 파일에 출력하는 특별한 상황이 아니면 <span class="fixed">doubleMe</span> 함수를 호출해도 프로그램은 “아 알았어요, 나중에 할게요!” 하고 실제 계산은 나중으로 미루고 맙니다. 그러다 실제 결과를 사용자에게 보여야 하는 상황이 되면, 첫번째 <span class="fixed">doubleMe</span> 는 두번째 <span class="fixed">doubleMe</span> 에게 “지금 당장 계산 결과가 필요해!” 라고 알리게 되고, 그러면 두번째 <span class="fixed">doubleMe</span> 는 세번째 <span class="fixed">doubleMe</span> 에게 같은 말을 하고, 그러면 세번째 <span class="fixed">doubleMe</span> 는 비로소 마지못해 1에 2를 곱한 2를 반환합니다. 두번째 <span class="fixed">doubleMe</span> 는 받은 2에 2를 곱해 4를 반환하고, 첫번째 <span class="fixed">doubleMe</span> 는 받은 4에 2를 곱해 반환해야 할 리스트의 첫번째 값이 8이라는 것을 사용자에게 알려줍니다. 그러므로, 정말 필요해지는 때에 리스트를 딱 한번만 훑어보게 됩니다. 이러한 방법으로 게으른 언어에서는, 추가적인 데이터를 만들지 않고도 원하는 데이터를 효율적으로 만들어 낼 수 있습니다.
	  </p>
	  <p>
	    <img src="./files/boat.png" class="right" alt="boat" width="160" height="153">
	    하스켈은 <em>정적으로 타입이 정해지는(statically typed)</em> 언어입니다. 즉, 여러분이 프로그램을 “컴파일 할 때", 컴파일러는 이 프로그램의 이 부분은 숫자다, 저 부분은 문자열이다, 등의 것들을 계산해서 알고 있습니다. 그래서 잠재적인 오류들을 상당 부분 “컴파일 할 때" 미리 찾아낼 수 있습니다. 만약 숫자와 문자열을 더하려고 하면 컴파일러가 화를 내므로 이런 류의 오류를 미리 찾을 수 있겠지요. 하스켈은 <em>타입 유추 (type inference)</em> 기능을 가진 아주 좋은 타입 시스템을 사용합니다. 하스켈의 타입 시스템이 똑똑하게 코드의 각 부분의 타입을 유추해 내기 때문에 사용자가 직접 코드에 일일이 타입을 적어줄 필요가 없습니다. <span class="fixed">a = 5 + 4</span> 라고 쓰면, 하스켈에게 굳이 <span class="fixed">a</span>가 숫자라고 알려주지 않아도 알아서 숫자임을 알아냅니다. 타입 유추 덕분에 편리해질 뿐만 아니라 코드를 더 일반적으로(general) 작성할 수도 있습니다. 만약 두 개의 인자를 받아 둘을 더하는 함수를 작성할 때 각 인자의 타입을 적지 않아도, 이 함수에 주어진 두 개의 인자가 숫자처럼 동작할 수 있는 타입이면(주석,부연 - 덧셈만 할 수 있으면) 문제없이 작동할 것입니다.
	  </p>
	  <p>
	    하스켈은 <em>우아</em>하고 <em>간결</em>합니다.고수준의 개념들을 사용하기 때문에, 하스켈 프로그램은 같은 기능을 하도록 작성된 명령형 언어의 프로그램들보다 보통 짧습니다. 짧은 프로그램은 긴 프로그램보다 관리하기도 쉽고 버그도 더 적습니다.
	  </p>
	  <p>
	    하스켈은 <em>정말 똑똑한 사람들</em>(박사들을 포함한)이 만들었습니다. 하스켈은 1987년 아주 끝내주는 언어를 디자인하기 위해 조직된 연구 위원회가 개발하기 시작했습니다. 그리고 2003년에 (비로소!) 하스켈 언어의 안정된 버전을 정의한 하스켈 보고서(Haskell Report)가 발행되었습니다.
	  </p>
	  <a name="what-you-need"></a><h2>들어가기에 앞서 필요한 것!</h2>
	  <p>
	    텍스트 편집기와 하스켈 컴파일러이지요. 아마도 이미 사용중인 텍스트 편집기는 있을 테니 그건 생략하기로 합시다. 이 책에서는 가장 널리 쓰이는 하스켈 컴파일러인 GHC를 쓸 겁니다. 가장 좋은 방법은 단순히 하스켈과 도구들 이 포함된 <a href="http://www.haskell.org/platform/">&quot;The Haskell Platform&quot;</a>을 다운 받는 것 입니다.
	  </p>
	  <p>
	    GHC는 하스켈 스크립트(보통 확장자는 .hs를 씁니다)를 받아 컴파일하는 기능 뿐 아니라, 대화식(interactive) 프로그래밍 모드도 제공하지요. 읽어 들인 스크립트의 함수를 호출하면 화면에서 바로 볼 수 있습니다. 매번 수정 할 때마다 컴파일 하는 것 보다 훨씬 쉽고 빠르겠지요. 대화식 모드는 프롬프트에서 <span class="fixed">ghci</span> 라는 커맨드로 실행 할 수 있습니다. <span class="fixed">myfunctions.hs</span>라는 파일 안에 몇 함수들을 작성 해 놓고, 같은 폴더에서 <span class="fixed">ghci</span>를 실행 시킨 후, <span class="fixed">:l myfunctions</span>라고 입력하면 파일 안에 있던 함수들이 로드되어 사용 할 수 있게 되지요. 만약 이미 로드된 .hs 스크립트 파일을 수정했다면, 다시 <span class="fixed">:l myfunctions</span>를 입력하거나 <span class="fixed">:r</span>을 입력하면 됩니다. <span class="fixed">:r</span>은 현재 쓰고 있는 모듈들을 다시 로드하는 명령어입니다. 보통 저는 .hs 파일 안에 함수들을 정의 해 놓고 로드 해서 쓰고, 다시 고치고 로드하고 하는 식으로 작업합니다. 앞으로의 예제에서는 이런 방법을 사용하겠습니다.
	  </p>
          <div class="footdiv">
            <ul>
              <li style="text-align:left">
              </li>
              <li style="text-align:center">
                <a href="http://haskell.or.kr/chapters.html">Table of contents</a>
              </li>
              <li style="text-align:right">
                <a href="http://haskell.or.kr/starting-out.html" class="nxtlink">Starting Out</a>
              </li>
            </ul>
          </div>
        </div>
	<script type="text/javascript" src="./files/shCore.js"></script>
	<script type="text/javascript" src="./files/shBrushHaskell.js"></script>
	<script type="text/javascript" src="./files/shBrushPlain.js"></script>
	<script type="text/javascript">
	  dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
	  dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
	</script>
      </div>

    </body>
</html>
