<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Recursion - Learn You a Haskell for Great Good!</title>

<base href=".">
<style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style>
<link rel="shortcut icon" href="./favicon.png" type="image/png">
        <link rel="prev" href="./syntax-in-functions">
        <link rel="next" href="./higher-order-functions">
<link type="text/css" rel="stylesheet" href="./files/SyntaxHighlighter.css">
<body class="introcontent">
<div class="bgwrapper">
    <div id="content">
                <div class="footdiv" style="margin-bottom:25px;">
                <ul>
                    <li style="text-align:left">
                                                        <a href="./syntax-in-functions" class="prevlink">Syntax in Functions</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="./chapters">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="./higher-order-functions" class="nxtlink">Higher Order Functions</a>
                                            </li>
                </ul>
            </div>
        <h1 style="margin-left:-2px">재귀</h1>
<a name="hello-recursion"></a><h2>재귀야 안녕?</h2>
<img src="./files/recursion.png" alt="SOVIET RUSSIA" class="left" width="250" height="179">
<p>이번 챕터에서는 재귀에 대해 더 자세히 알아보고, 하스켈에서 재귀가 왜 중요한지,  문제를 재귀적으로 접근해서 간결하고 우아하게 해결하는 법 등을 알아보도록 하겠습니다.</p>
<p>만약 아직도 재귀가 뭔지 잘 모르겠다면 이 문장을 다시 읽어보세요. 하하~ 농담입니다. 사실 재귀는 함수를 정의하는 방법 중 하나로써, 함수 정의 안에서 자기를 다시 호출하는 함수를 말합니다. 수학에서의 정의들도 종종 재귀의 형태를 보입니다. 예를 들면, 피보나치 수열이 재귀적으로 정의 되어있지요. 우선, 처음 두 숫자는 재귀적이지 않게 정의되어 있습니다. 이를 <i>F(0) = 0, F(1) = 1</i> 라고 표현합니다. 0번째, 1번째 피보나치 숫자는 각각 0, 1이라는 것을 의미하지요. 다음으로, 이제 다른 아무 자연수에 대해서는 앞의 두 피보나치 수의 합이라고 정의합시다. 그럼 <i>F(n) = F(n-1) + F(n-2)</i> 라고 쓸 수 있겠네요. 그러므로, <i>F(3)</i> 은 <i>F(2) + F(1)</i>이 되고, 다시 <i>(F(1) + F(0)) + F(1)</i> 이 되겠습니다. 이제 재귀적이지 않은 피보나치 수만 모였으므로, <i>F(3)</i> 은 2라고 도출 할 수 있습니다. 재귀적이지 않게 정의된 한 두가지 정도의 (예제에서는 <i>F(0)</i>, <i>F(1)</i> 같은 경우) 경우를 <em>edge condition</em> 이라 부릅니다. 재귀 함수에서 이 부분이 호출의 끝이 되므로 아주 중요하지요. 만약 예제에서 <i>F(0)</i>과 <i>F(1)</i>을 따로 정의하지 않았다면, 함수는 음수까지 계속되면서 끝나지 않았을 것입니다. 만약 갑자기, <i>F(-2000)</i> 는 <i>F(-2001) + F(-2002)</i> 이라고 한다면 끝이 보이지 않겠지요!</p>
<p>Recursion is important to Haskell because unlike imperative languages, you do computations in Haskell by declaring what something <i>is</i> instead of declaring <i>how</i> you get it. That's why there are no while loops or for loops in Haskell and instead we many times have to use recursion to declare what something is.</p>
<a name="maximum-awesome"></a><h2>Maximum awesome</h2>
<p><span class="fixed">maximum</span> 함수는 정렬 될 수 있는(<span class="fixed">Ord</span> 타입클래스에 속해 있는) 것들의 리스트를 받아서 최대값을 돌려주는 함수입니다. 이걸 명령형 방식으로는 어떻게 구현할까요? 아마 저장해 놓을 변수를 선언해놓고, 리스트를 돌면서 저장해 놓은 값보다 더 크다면 변수에 저장하는 식이겠지요. 리스트를 다 탐색하고 나면 선언한 변수의 값이 최대값이 되겠네요. 휴! 이 간단한 알고리즘을 설명하는데 이렇게 많은 말이 필요하네요.</p>
<p>그럼 제귀적으로는 어떻게 정의하는지 봅시다. 우선 "멤버가 한개만 있는 리스트의 최대값은 그 멤버"라는 Edge Condition을 정의합시다. 더 긴 리스트의 경우는 머리(head)가 꼬리(tail)의 최대값보다 크면 최대값이라고 정의합니다. 꼬리쪽의 최대값이 크다면 꼬리쪽이라고 하고요. 다 됐습니다! 이제 하스켈에서 어떻게 구현했는지 보시지요.</p>
<pre name="code" class="haskell:hs" style="display: none;">maximum' :: (Ord a) =&gt; [a] -&gt; a
maximum' [] = error "maximum of empty list"
maximum' [x] = x
maximum' (x:xs) 
    | x &gt; maxTail = x
    | otherwise = maxTail
    where maxTail = maximum' xs
</pre>
<p>보시다시피, 패턴 매칭과 재귀가 기가 막히게 잘 들어맞네요! 대부분의 명령형 언어에는 패턴 매칭이 없어서, edge condition을 체크하려면 if else 문으로 도배를 해야합니다. 그러나 하스켈에서는 단순히 패턴을 정의하면 되지요. 첫번째 edge condition은 비어있는 리스트면 에러를 내라고 하네요. 비어있는 리스트에서 최대값을 구할 수 없으니 맞는 말 아닐까요? 흠, 잘 모르겠습니다. 두번째 패턴 또한 edge condition입니다. 멤버 하나짜리 리스트면 그냥 그 멤버를 돌려주라는 얘기네요.</p>
<p>세번째 패턴이 바로 중요한 알고리즘이 구현되는 곳입니다. 리스트를 머리(head)와 꼬리(tail)로 나누기 위해 패턴 매칭을 사용했습니다. 재귀적으로 리스트를 다룰 때, 보통 관습적으로 이렇게 표현하니 익숙해지시기 바랍니다. <span class="fixed">maxTail</span> 이 나머지 부분(꼬리)에서의 최대값이라는 걸 정의 하기 위해 <i>where</i>를 썼습니다. 그럼 머리(head)가 나머지 부분의 최대값보다 큰지 확인해서 맞으면 머리, 아니면 나머지 리스트의 최대값을 돌려주면 되겠네요.</p>
<p>예제를 보면서 어떻게 작동하는지 확인해 봅시다. <span class="fixed">[2,5,1]</span> 라는 리스트가 있고, 이것을 인자로 <span class="fixed">maximum'</span>을 호출해 봅시다. 그러면 처음 두 패턴은 일치하지 않겠지요. 세번째 패턴에서 리스트는 <span class="fixed">2</span>와 <span class="fixed">[5,1]</span>로 쪼개질 것입니다. <span class="fixed">where</span>절에서 <span class="fixed">[5,1]</span> 의 최대값을 알고 싶어하니 따라가봅시다.  또 세번째 패턴과 일치하니, <span class="fixed">5</span>와 <span class="fixed">[1]</span>로 쪼개지겠군요. 또 다시 <i>where</i> 절에서 <span class="fixed">[1]</span> 의 최대값을 구하려합니다. 이것은 두번째 패턴인 edge condition이니 <span class="fixed">1</span> 이겠군요. 마지막으로, 다시 한 단계 전으로 돌아가 비교해보면 <span class="fixed">[5,1]</span>의 최대값은 <span class="fixed">5</span> 가 되고, 다시 한 단계 전으로 돌아가 <span class="fixed">2</span>와 비교하면 전체의 최대값은 <span class="fixed">5</span>가 됩니다.</p>
<p><span class="fixed">max</span>라는 함수를 사용하면 더 깔끔하게 구현할 수 있습니다. <span class="fixed">max</span>는 두 숫자를 받아서 더 큰 수를 돌려주는 함수인 것을 기억하시지요? 아래에 <span class="fixed">max</span>를 사용하여 <span class="fixed">maximum'</span>을 다시 작성해 보았습니다.</p>
<pre name="code" class="haskell:hs" style="display: none;">maximum' :: (Ord a) =&gt; [a] -&gt; a
maximum' [] = error "maximum of empty list"
maximum' [x] = x
maximum' (x:xs) = max x (maximum' xs)
</pre>
<p>정말 우아하네요! 전체 리스트의 최대값은 첫번째 멤버와 나머지 리스트의 최대값 중 더 큰 수라는 알고리즘은 동일합니다.</p>
<img src="./files/maxs.png" alt="max" class="center" width="651" height="267">
<a name="a-few-more-recursive-functions"></a><h2>재귀 함수들을 좀 더 만나봅시다</h2>
<p>이제 재귀적으로 생각하는 법을 배웠으니, 재귀 함수들을 좀 더 만들어봅시다.처음으로는 <span class="fixed">replicate</span>함수를 만들어 보겠습니다. <span class="fixed">replicate</span>함수는 <span class="fixed">Int</span> 타입의 인자 두 개를 받아, 첫 번째 인자가 두 번째 인자 만큼 복제되어 들어있는 리스트를 돌려줍니다. 예를 들어 <span class="fixed">replicate 3 5</span> 은 <span class="fixed">[5,5,5]</span>을 돌려주지요. Edge Condition이 무엇이 될 지 생각해봅시다. 아마 0 이하일때 라는 조건일 것 같은데요. 어떤 것을 0번 복제하려고 하면 비어있는 리스트를 돌려줘야 하겠지요. 또한 음수 번 복제하는 것도 말이 안 되니 음수에 대해서도 빈 리스트를 돌려줘야겠네요.</p>
<pre name="code" class="haskell:hs" style="display: none;">replicate' :: (Num i, Ord i) =&gt; i -&gt; a -&gt; [a]
replicate' n x
    | n &lt;= 0    = []
    | otherwise = x:replicate' (n-1) x
</pre>
<p>We used guards here instead of patterns because we're testing for a boolean condition. If <span class="fixed">n</span> is less than or equal to 0, return an empty list. Otherwise return a list that has <span class="fixed">x</span> as the first element and then <span class="fixed">x</span> replicated n-1 times as the tail. Eventually, the <span class="fixed">(n-1)</span> part will cause our function to reach the edge condition.</p>
<div class="hintbox"><em>Note:</em> <span class="fixed">Num</span> is not a subclass of <span class="fixed">Ord</span>. That means that what constitutes for a number doesn't really have to adhere to an ordering. So that's why we have to specify both the <span class="fixed">Num</span> and <span class="fixed">Ord</span> class constraints when doing addition or subtraction and also comparison.</div>
<p>Next up, we'll implement <span class="fixed">take</span>. It takes a certain number of elements from a list. For instance, <span class="fixed">take 3 [5,4,3,2,1]</span> will return <span class="fixed">[5,4,3]</span>. If we try to take 0 or less elements from a list, we get an empty list. Also if we try to take anything from an empty list, we get an empty list. Notice that those are two edge conditions right there. So let's write that out:</p>
<pre name="code" class="haskell:hs" style="display: none;">take' :: (Num i, Ord i) =&gt; i -&gt; [a] -&gt; [a]
take' n _
    | n &lt;= 0   = []
take' _ []     = []
take' n (x:xs) = x : take' (n-1) xs
</pre>
<img src="./files/painter.png" alt="painter" class="right" width="350" height="276">
<p>The first pattern specifies that if we try to take a 0 or negative number of elements, we get an empty list. Notice that we're using <span class="fixed">_</span> to match the list because we don't really care what it is in this case. Also notice that we use a guard, but without an <span class="fixed">otherwise</span> part. That means that if <span class="fixed">n</span> turns out to be more than 0, the matching will fall through to the next pattern. The second pattern indicates that if we try to take anything from an empty list, we get an empty list. The third pattern breaks the list into a head and a tail. And then we state that taking <span class="fixed">n</span> elements from a list equals a list that has <span class="fixed">x</span> as the head and then a list that takes <span class="fixed">n-1</span> elements from the tail as a tail. Try using a piece of paper to write down how the evaluation would look like if we try to take, say, 3 from <span class="fixed">[4,3,2,1]</span>.</p>
<p><span class="fixed">reverse</span> simply reverses a list. Think about the edge condition. What is it? Come on ... it's the empty list! An empty list reversed equals the empty list itself. O-kay. What about the rest of it? Well, you could say that if we split a list to a head and a tail, the reversed list is equal to the reversed tail and then the head at the end.</p>
<pre name="code" class="haskell:hs" style="display: none;">reverse' :: [a] -&gt; [a]
reverse' [] = []
reverse' (x:xs) = reverse' xs ++ [x]
</pre>
<p>There we go!</p>
<p>Because Haskell supports infinite lists, our recursion doesn't really have to have an edge condition. But if it doesn't have it, it will either keep churning at something infinitely or produce an infinite data structure, like an infinite list. The good thing about infinite lists though is that we can cut them where we want. <span class="fixed">repeat</span> takes an element and returns an infinite list that just has that element. A recursive implementation of that is really easy, watch.</p>
<pre name="code" class="haskell:hs" style="display: none;">repeat' :: a -&gt; [a]
repeat' x = x:repeat' x
</pre>
<p>Calling <span class="fixed">repeat 3</span> will give us a list that starts with <span class="fixed">3</span> and then has an infinite amount of 3's as a tail. So calling <span class="fixed">repeat 3</span> would evaluate like <span class="fixed">3:repeat 3</span>, which is <span class="fixed">3:(3:repeat 3)</span>, which is <span class="fixed">3:(3:(3:repeat 3))</span>, etc. <span class="fixed">repeat 3</span> will never finish evaluating, whereas <span class="fixed">take 5 (repeat 3)</span> will give us a list of five 3's. So essentially it's like doing <span class="fixed">replicate 5 3</span>.</p>
<p><span class="fixed">zip</span> takes two lists and zips them together. <span class="fixed">zip [1,2,3] [2,3]</span> returns <span class="fixed">[(1,2),(2,3)]</span>, because it truncates the longer list to match the length of the shorter one. How about if we zip something with an empty list? Well, we get an empty list back then. So there's our edge condition. However, <span class="fixed">zip</span> takes two lists as parameters, so there are actually two edge conditions.</p>
<pre name="code" class="haskell:hs" style="display: none;">zip' :: [a] -&gt; [b] -&gt; [(a,b)]
zip' _ [] = []
zip' [] _ = []
zip' (x:xs) (y:ys) = (x,y):zip' xs ys
</pre>
<p>First two patterns say that if the first list or second list is empty, we get an empty list. The third one says that two lists zipped are equal to pairing up their heads and then tacking on the zipped tails. Zipping <span class="fixed">[1,2,3]</span> and <span class="fixed">['a','b']</span> will eventually try to zip <span class="fixed">[3]</span> with <span class="fixed">[]</span>. The edge condition patterns kick in and so the result is <span class="fixed">(1,'a'):(2,'b'):[]</span>, which is exactly the same as <span class="fixed">[(1,'a'),(2,'b')]</span>.</p>
<p>Let's implement one more standard library function — <span class="fixed">elem</span>. It takes an element and a list and sees if that element is in the list. The edge condition, as is most of the times with lists, is the empty list. We know that an empty list contains no elements, so it certainly doesn't have the droids we're looking for.</p>
<pre name="code" class="haskell:hs" style="display: none;">elem' :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool
elem' a [] = False
elem' a (x:xs)
    | a == x    = True
    | otherwise = a `elem'` xs 
</pre>
<p>Pretty simple and expected. If the head isn't the element then we check the tail. If we reach an empty list, the result is <span class="fixed">False</span>.</p>
<a name="quick-sort"></a><h2>Quick, sort!</h2>
<p>We have a list of items that can be sorted. Their type is an instance of the <span class="fixed">Ord</span> typeclass. And now, we want to sort them! There's a very cool algoritm for sorting called quicksort. It's a very clever way of sorting items. While it takes upwards of 10 lines to implement quicksort in imperative languages, the implementation is much shorter and elegant in Haskell. Quicksort has become a sort of poster child for Haskell. Therefore, let's implement it here, even though implementing quicksort in Haskell is considered really cheesy because everyone does it to showcase how elegant Haskell is.</p>
<img src="./files/quickman.png" alt="quickman" class="left" width="180" height="235">
<p>So, the type signature is going to be <span class="fixed">quicksort :: (Ord a) =&gt; [a] -&gt; [a]</span>. No surprises there. The edge condition? Empty list, as is expected. A sorted empty list is an empty list. Now here comes the main algorithm: <em>a sorted list is a list that has all the values smaller than (or equal to) the head of the list in front (and those values are sorted), then comes the head of the list in the middle and then come all the values that are bigger than the head (they're also sorted).</em> Notice that we said <i>sorted</i> two times in this definition, so we'll probably have to make the recursive call twice! Also notice that we defined it using the verb <i>is</i> to define the algorithm instead of saying <i>do this, do that, then do that ...</i>. That's the beauty of functional programming! How are we going to filter the list so that we get only the elements smaller than the head of our list and only elements that are bigger? List comprehensions. So, let's dive in and define this function.</p>
<pre name="code" class="haskell:hs" style="display: none;">quicksort :: (Ord a) =&gt; [a] -&gt; [a]
quicksort [] = []
quicksort (x:xs) = 
    let smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x]
        biggerSorted = quicksort [a | a &lt;- xs, a &gt; x]
    in  smallerSorted ++ [x] ++ biggerSorted
</pre>
<p>Let's give it a small test run to see if it appears to behave correctly.</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; quicksort [10,2,5,3,1,6,7,4,2,3,4,8,9]
[1,2,2,3,3,4,4,5,6,7,8,9,10]
ghci&gt; quicksort "the quick brown fox jumps over the lazy dog"
"        abcdeeefghhijklmnoooopqrrsttuuvwxyz"
</pre>
<p>Booyah! That's what I'm talking about! So if we have, say <span class="fixed">[5,1,9,4,6,7,3]</span> and we want to sort it, this algorithm will first take the head, which is <span class="fixed">5</span> and then put it in the middle of two lists that are smaller and bigger than it. So at one point, you'll have <span class="fixed">[1,4,3] ++ [5] ++ [9,6,7]</span>. We know that once the list is sorted completely, the number <span class="fixed">5</span> will stay in the fourth place since there are 3 numbers lower than it and 3 numbers higher than it. Now, if we sort <span class="fixed">[1,4,3]</span> and <span class="fixed">[9,6,7]</span>, we have a sorted list! We sort the two lists using the same function. Eventually, we'll break it up so much that we reach empty lists and an empty list is already sorted in a way, by virtue of being empty. Here's an illustration:</p>
<img src="./files/quicksort.png" alt="quicksort" class="center" width="799" height="332">
<p>An element that is in place and won't move anymore is represented in <span style="color:#FF6600;font-weight:bold;">orange</span>. If you read them from left to right, you'll see the sorted list. Although we chose to compare all the elements to the heads, we could have used any element to compare against. In quicksort, an element that you compare against is called a pivot. They're in <span style="color:#009900;font-weight:bold">green</span> here. We chose the head because it's easy to get by pattern matching. The elements that are smaller than the pivot are <span style="color:#0f0;font-weight:bold">light green</span> and elements larger than the pivot are <span style="color:#030;font-weight:bold">dark green</span>. The yellowish gradient thing represents an application of quicksort.</p>
<a name="thinking-recursively"></a><h2>Thinking recursively</h2>
<p>We did quite a bit of recursion so far and as you've probably noticed, there's a pattern here. Usually you define an edge case and then you define a function that does something between some element and the function applied to the rest. It doesn't matter if it's a list, a tree or any other data structure. A sum is the first element of a list plus the sum of the rest of the list. A product of a list is the first element of the list times the product of the rest of the list. The length of a list is one plus the length of the tail of the list. Ekcetera, ekcetera ...</p><p>
<img src="./files/brain.png" alt="brain" class="left" width="250" height="219">
</p><p>Of course, these also have edge cases. Usually the edge case is some scenario where a recursive application doesn't make sense. When dealing with lists, the edge case is most often the empty list. If you're dealing with trees, the edge case is usually a node that doesn't have any children.</p>
<p>It's similar when you're dealing with numbers recursively. Usually it has to do with some number and the function applied to that number modified. We did the factorial function earlier and it's the product of a number and the factorial of that number minus one. Such a recursive application doesn't make sense with zero, because factorials are defined only for positive integers. Often the edge case value turns out to be an identity. The identity for multiplication is 1 because if you multiply something by 1, you get that something back. Also when doing sums of lists, we define the sum of an empty list as 0 and 0 is the identity for addition. In quicksort, the edge case is the empty list and the identity is also the empty list, because if you add an empty list to a list, you just get the original list back.</p>
<p>So when trying to think of a recursive way to solve a problem, try to think of when a recursive solution doesn't apply and see if you can use that as an edge case, think about identities and think about whether you'll break apart the parameters of the function (for instance, lists are usually broken into a head and a tail via pattern matching) and on which part you'll use the recursive call.</p>

                <div class="footdiv">
                <ul>
                    <li style="text-align:left">
                                                        <a href="./syntax-in-functions" class="prevlink">Syntax in Functions</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="./chapters">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="./higher-order-functions" class="nxtlink">Higher Order Functions</a>
                                            </li>
                </ul>
            </div>
        </div>
    <script type="text/javascript" src="./files/shCore.js"></script>
    <script type="text/javascript" src="./files/shBrushHaskell.js"></script>
    <script type="text/javascript" src="./files/shBrushPlain.js"></script>
    <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script>
</div>



</body></html>
