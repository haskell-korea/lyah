<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0049)./types-and-typeclasses -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Types and Typeclasses - Learn You a Haskell for Great Good!</title>

<!--<base href="./">--><base href=".">
<style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style>
<link rel="shortcut icon" href="./favicon.png" type="image/png">
        <link rel="prev" href="./starting-out">
        <link rel="next" href="./syntax-in-functions">
<link type="text/css" rel="stylesheet" href="./files/SyntaxHighlighter.css">
<body class="introcontent">
<div class="bgwrapper">
    <div id="content">
                <div class="footdiv" style="margin-bottom:25px;">
                <ul>
                    <li style="text-align:left">
                                                        <a href="./starting-out.html" class="prevlink">Starting Out</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="./chapters.html">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="./syntax-in-functions.html" class="nxtlink">Syntax in Functions</a>
                                            </li>
                </ul>
            </div>
        <h1>타입과 타입클래스</h1>
<a name="believe-the-type"></a><h2>타입을 믿습니다!</h2>
<img src="./files/cow.png" alt="moo" class="left" width="180" height="127">
<p>이전에 하스켈은 정적인 타입 시스템을 채택하고 있다고 소개했었습니다. 모든 expression의 타입을 컴파일 할 때 알 수 있어서 더욱 안전하게 코딩을 할 수 있지요. 만약 불리언 타입을 숫자로 나누는 코드를 작성했다면 컴파일조차 되지 않을 것입니다. 이런 에러들을 컴파일 할 때 잡을 수 있으니, 실행 하다 죽는 것 보다야 훨씬 좋겠지요. 하스켈 안의 모든 것에는 타입이 있기 때문에, 컴파일러가 프로그램에 대해 사전에 많은 것 들을 알 수 있게 됩니다.</p>
<p>하스켈에는 Java나 Pascal에는 없는 타입 추론 기능이 있습니다. 숫자를 쓰면 따로 그게 숫자라고 알려줄 필요가 없다는 것이죠. 하스켈이 스스로 타입 추론이 가능하므로, 작성한 함수나 수식에 대해 명시적으로 타입을 지정하지 않아도 잘 동작합니다. 이제 대충 타입을 보았으니, 어느정도 하스켈의 기본을 배운 것 입니다.  그러나 타입 시스템을 이해하는 것은 하스켈을 배우는 데 있어서 아주 중요한 부분이므로 좀 더 알아보겠습니다.</p>
<p>타입은 각 수식이 어떤 카테고리에 속하는지 표시해주는 일종의 라벨같은 것입니다. 예를 들면 <span class="fixed">True</span>라는 식은 boolean 타입, <span class="fixed">"hello"</span>라는 식은 문자열 타입, 하는 식이죠.</p>
<p>이제 GHCI로 어떻게 수식의 타입을 알아보는지 배워보겠습니다. 단순히 <span class="fixed">:t</span> 와 수식을 같이 입력하는 것으로 확인 할 수 있습니다. 한번 해볼까요?</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; :t 'a'
'a' :: Char
ghci&gt; :t True
True :: Bool
ghci&gt; :t "HELLO!"
"HELLO!" :: [Char]
ghci&gt; :t (True, 'a')
(True, 'a') :: (Bool, Char)
ghci&gt; :t 4 == 5
4 == 5 :: Bool
</pre>
<p>
<img src="./files/bomb.png" alt="bomb" class="right" width="171" height="144">
<span class="fixed">:t</span> 와 수식을 입력하면 "수식 <span class="fixed">::</span> 타입" 형태로 출력되는 것을 볼 수 있습니다. <span class="fixed">::</span> 는 “~라는 타입을 갖는다”로 해석할 수 있겠네요. 명시적 타입은 항상 첫 글자를 대문자로 표현합니다. 보시다시피, <span class="fixed">'a'</span> 는 <span class="fixed">Char</span> 타입을 갖습니다. <span class="fixed">Char</span>가 <i>문자(Character)</i>의 준말을 의미한다는 건 쉽게 떠올릴 수 있습니다. <span class="fixed">True</span> 는 <span class="fixed">Bool</span> 타입입니다. 이해가 되네요.  음...  그럼 이런 경우는 어떨까요? <span class="fixed">"HELLO!"</span> 의 타입을 물어보면 <span class="fixed">[Char]</span> 라고 알려줍니다. 대괄호는 리스트를 의미하니, 이것을 <i>문자의 리스트</i>라고 읽을 수 있겠네요. 리스트와는 달리 튜플은 길이가 다르면 다른 타입을 갖습니다. 그러므로 <span class="fixed">(True, 'a')</span> 의 타입은 <span class="fixed">(Bool, Char)</span> 이고, <span class="fixed">('a','b','c')</span> 는 <span class="fixed">(Char, Char, Char)</span> 타입이라고 할 수 있겠네요. <span class="fixed">4 == 5</span> 는 언제나 <span class="fixed">False</span> 를 나타내므로 타입은 <span class="fixed">Bool</span> 입니다.</p>
<p>
함수도 타입이 있습니다. 함수를 작성할 때 명시적으로 타입을 선언 할 수 있습니다. 이건 매우 짧은 함수를 작성 할 때를 제외하고는, 대체로 좋은 습관으로 볼 수 있습니다.  여기서부터 작성하는 모든 함수에는 타입을 지정하도록 하겠습니다. 이전에 List Comprehension을 이용해 문자열에서 대문자만 걸러내는 함수를 만들었던 것을 기억하시나요? 거기에 타입 선언을 추가하면 아래처럼 됩니다.</p>

<pre name="code" class="haskell: hs" style="display: none;">removeNonUppercase :: [Char] -&gt; [Char]
removeNonUppercase st = [ c | c &lt;- st, c `elem` ['A'..'Z']] 
</pre>
<p>
<span class="fixed">removeNonUppercase</span> 는 <span class="fixed">[Char] -&gt; [Char]</span> 타입을 갖는데요, 이것은 문자열을 받아서 문자열로 매핑 해준다는 뜻입니다. 이 함수는 문자열을 받아 문자열을 돌려주는 함수이기 때문이지요. <span class="fixed">[Char]</span> 타입은 <span class="fixed">String</span> 타입과 똑같으니, <span class="fixed">removeNonUppercase :: String -&gt; String</span> 이렇게 쓰는 것이 더 명확해 보입니다. 타입 선언을 명시적으로 하긴 했지만, 컴파일러가 이 함수의 타입을 추론 할 수 있기 때문에 사실 명시적인 지정을 하지 않아도 됩니다. 그런데, 여러 개의 인자를 받는 함수인 경우는 어떻게 타입을 선언해야 할까요? 아래에 3개의 정수 인자를 받아 더하는 간단한 함수 예제가 있습니다.
</p>
<pre name="code" class="haskell: hs" style="display: none;">addThree :: Int -&gt; Int -&gt; Int -&gt; Int
addThree x y z = x + y + z
</pre>
<p>인자들 간에는 <span class="fixed">-&gt;</span> 로 구분이 되고, 리턴 타입도 똑같이 <span class="fixed">-&gt;</span> 로 구분됩니다. 마지막에 있는 것이 리턴 타입이니, 처음 세 타입이 인자의 타입이겠네요. 왜 인자와 리턴 타입 사이를 <span class="fixed">Int, Int, Int -&gt; Int</span> 와 같이 명시적으로 표현하지 않고, 모두 똑같이 <span class="fixed">-&gt;</span>로만 구분하는지는 나중에 알아보도록 하겠습니다.
</p>
<p>만약 작성한 함수의 타입을 선언하고 싶은데, 어떤 타입인지 잘 모르겠다면 작성한 함수를 <span class="fixed">:t</span> 로 체크해보면 됩니다. 함수도 수식이니까 <span class="fixed">:t</span> 가 문제없이 잘 동작 할 것입니다.</p>
<p>몇 가지 일반적인 타입들을 훑어봅시다.</p>
<p>
<span class="label type">Int</span> 는 정수(Integer)의 준말입니다. 숫자 전체에 쓰일 수 있지요. 그러나, <span class="fixed">7</span> 은 <span class="fixed">Int</span> 가 될 수 있지만, <span class="fixed">7.2</span> 는 될 수 없습니다. <span class="fixed">Int</span> 는 바운드된(bounded) 타입입니다. 즉 최소값과 최대값이 있다는 뜻입니다. 보통 32비트 머신에서 <span class="fixed">Int</span> 의 최대값은 2147483647, 최소값은 -2147483648 입니다.
</p>
<p><span class="label type">Integer</span> 는 에.. 또 정수(Integer)를 의미합니다. 그러나 Int 와의 큰 차이점은 이건 바운드(bounded)되지 않았다는 것이지요. 그래서, 아~주 아주 큰 숫자도 사용 할 수 있습니다. 하지만, <span class="fixed">Int</span> 는 더 효율적이지요.
</p>
<pre name="code" class="haskell: hs" style="display: none;">factorial :: Integer -&gt; Integer
factorial n = product [1..n]
</pre>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; factorial 50
30414093201713378043612608166064768844377641568960512000000000000
</pre>
<p><span class="label type">Float</span> 는 single precision의 부동 소수점 실수입니다.</p>
<pre name="code" class="haskell: hs" style="display: none;">circumference :: Float -&gt; Float
circumference r = 2 * pi * r
</pre>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; circumference 4.0
25.132742
</pre>
<p><span class="label type">Double</span> 은 double precision의 부동 소수점 실수이지요.</p>
<pre name="code" class="haskell: hs" style="display: none;">circumference' :: Double -&gt; Double
circumference' r = 2 * pi * r
</pre>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; circumference' 4.0
25.132741228718345
</pre>
<p>
<span class="label type">Bool</span> 은 불리언 타입으로서, <span class="fixed">True</span> 와 <span class="fixed">False</span> 두가지 값 밖에 없습니다.
</p>
<p>
<span class="label type">Char</span> 타입은 문자를 의미합니다. 작은 따옴표와 함께 표현되지요. 문자의 리스트는 문자열(string)입니다.
</p>
<p>튜플도 타입이지만 길이와 구성 요소에 따라 달라지기 때문에, 이론적으로 무한한 튜플 타입이 가능합니다. 비어있는 튜플 <span class="label type">()</span> 도 오직 <span class="fixed">()</span> 라는 값을 가지는  타입입니다.</p>
<a name="type-variables"></a><h2>타입 변수</h2>
<p>
<span class="fixed">head</span>함수의 타입을 생각해보세요. <span class="fixed">head</span>는 특정 타입의 리스트를 받아 첫 번째 값을 돌려주는 함수였습니다. 무엇일까요? 한번 봅시다!
</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; :t head
head :: [a] -&gt; a
</pre>
<p>
<img src="./files/box.png" alt="box" class="left" width="130" height="93">
흠… 이 <span class="fixed">a</span> 가 뭐지요? 이게 타입인가요? 이전에 타입은 대문자로 시작한다고 했기 때문에 이건 정확히 타입은 아닐 것입니다. 이것은 사실 <em>타입 변수</em>라는 것이지요. 타입 변수라는 말은 즉, <span class="fixed">a</span> 가 어떠한 타입도 될 수 있다는 뜻입니다. 타입 변수는 다른 언어의 제네릭(generic)과 유사합니다. 타입 변수를 사용하는 함수들을 <em>다형 함수(polymorphic function)</em>라고 부릅니다. 어찌되었든 <span class="fixed">head</span> 의 타입은 특정 타입의 리스트를 받아서 첫 번째 값을 돌려주는 것이니 리턴 타입은 그 값의 타입이겠네요.
</p>
<p>타입 변수 이름을 1글자 이상으로도 사용할 수 있지만, 보통 a, b, c, d 처럼 한 글자로 지정합니다.</p>
<p>타입을 한번 확인해보지요. <span class="fixed">fst</span> 함수를 기억하시나요? 페어의 첫 번째 값을 돌려주는 함수였습니다.</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; :t fst
fst :: (a, b) -&gt; a
</pre>
<p>
<span class="fixed">fst</span>가 두 타입으로 이루어진 튜플을 받아서, 첫 번째 값과 같은 타입으로 돌려주는 것을 볼 수 있습니다. 이게 어떤 타입의 튜플에도 <span class="fixed">fst</span>함수를 쓸 수 있었던 이유입니다. <span class="fixed">a</span> 와 <span class="fixed">b</span> 는 단지 두 개의 타입 변수인 것일 뿐, 꼭 다른 타입일 필요는 없다는 것에 주의하세요. 리턴 타입이 첫 번째 값의 타입과 같다는 것을 나타내기 위해 저렇게 표현한 것 입니다.
</p>
<a name="typeclasses-101"></a><h2>타입클래스 101</h2>
<img src="./files/classes.png" alt="class" class="right" width="210" height="158">
<p>타입클래스란, 몇몇 행동들을 정의하는 일종의 인터페이스 같은 것입니다. 만약 어떤 타입이 한 타입클래스에 속한다는건, 이 타입이 속한 타입클래스가 정의한 행동들을 지원할 수 있도록 구현되었다는 의미입니다. 객체 지향적 프로그래밍에 익숙한 사람들이 타입클래스가 객체 언어의 클래스 같은 것인 줄 오해 하는 경우가 많습니다. 하하, 아니지요.  차라리, Java의 인터페이스 같은거라고 생각하는게 더 날겁니다.
</p>
<p>What's the type signature of the <span class="fixed">==</span> function?</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; :t (==)
(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool
</pre>
<div class="hintbox"><em>Note</em>: the equality operator, <span class="fixed">==</span> is a function. So are <span class="fixed">+</span>, <span class="fixed">*</span>, <span class="fixed">-</span>, <span class="fixed">/</span> and pretty much all operators. If a function is comprised only of special characters, it's considered an infix function by default. If we want to examine its type, pass it to another function or call it as a prefix function, we have to surround it in parentheses.</div>
<p>Interesting. We see a new thing here, the <span class="fixed">=&gt;</span> symbol. Everything before the <span class="fixed">=&gt;</span> symbol is called a <em>class constraint</em>. We can read the previous type declaration like this: the equality function takes any two values that are of the same type and returns a <span class="fixed">Bool</span>. The type of those two values must be a member of the <span class="fixed">Eq</span> class (this was the class constraint).</p>
<p>The <span class="fixed">Eq</span> typeclass provides an interface for testing for equality. Any type where it makes sense to test for equality between two values of that type should be a member of the <span class="fixed">Eq</span> class. All standard Haskell types except for IO (the type for dealing with input and output) and functions are a part of the <span class="fixed">Eq</span> typeclass.</p>
<p>The <span class="fixed">elem</span> function has a type of <span class="fixed">(Eq a) =&gt; a -&gt; [a] -&gt; Bool</span> because it uses <span class="fixed">==</span> over a list to check whether some value we're looking for is in it.</p>
<p>Some basic typeclasses:</p>
<p><span class="label class">Eq</span> is used for types that support equality testing. The functions its members implement are <span class="fixed">==</span> and <span class="fixed">/=</span>. So if there's an <span class="fixed">Eq</span> class constraint for a type variable in a function, it uses <span class="fixed">==</span> or <span class="fixed">/=</span> somewhere inside its definition. All the types we mentioned previously except for functions are part of <span class="fixed">Eq</span>, so they can be tested for equality.</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; 5 == 5
True
ghci&gt; 5 /= 5
False
ghci&gt; 'a' == 'a'
True
ghci&gt; "Ho Ho" == "Ho Ho"
True
ghci&gt; 3.432 == 3.432
True
</pre>
<p>
<span class="label class">Ord</span> is for types that have an ordering.</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; :t (&gt;)
(&gt;) :: (Ord a) =&gt; a -&gt; a -&gt; Bool
</pre>
<p>
All the types we covered so far except for functions are part of <span class="fixed">Ord</span>. <span class="fixed">Ord</span> covers all the standard comparing functions such as <span class="fixed">&gt;</span>, <span class="fixed">&lt;</span>, <span class="fixed">&gt;=</span> and <span class="fixed">&lt;=</span>. The <span class="fixed">compare</span> function takes two <span class="fixed">Ord</span> members of the same type and returns an ordering. <span class="label type">Ordering</span> is a type that can be <span class="fixed">GT</span>, <span class="fixed">LT</span> or <span class="fixed">EQ</span>, meaning <i>greater than</i>, <i>lesser than</i> and <i>equal</i>, respectively. 
</p><p>To be a member of <span class="fixed">Ord</span>, a type must first have membership in the prestigious and exclusive <span class="fixed">Eq</span> club.</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; "Abrakadabra" &lt; "Zebra"
True
ghci&gt; "Abrakadabra" `compare` "Zebra"
LT
ghci&gt; 5 &gt;= 2
True
ghci&gt; 5 `compare` 3
GT
</pre>
<p>Members of <span class="label class">Show</span> can be presented as strings. All types covered so far except for functions are a part of <span class="fixed">Show</span>. The most used function that deals with the <span class="fixed">Show</span> typeclass is <span class="fixed">show</span>. It takes a value whose type is a member of <span class="fixed">Show</span> and presents it to us as a string.</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; show 3
"3"
ghci&gt; show 5.334
"5.334"
ghci&gt; show True
"True"
</pre>
<p><span class="label class">Read</span> is sort of the opposite typeclass of <span class="fixed">Show</span>. The <span class="fixed">read</span> function takes a string and returns a type which is a member of <span class="fixed">Read</span>.</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; read "True" || False
True
ghci&gt; read "8.2" + 3.8
12.0
ghci&gt; read "5" - 2
3
ghci&gt; read "[1,2,3,4]" ++ [3]
[1,2,3,4,3]
</pre>
<p>So far so good. Again, all types covered so far are in this typeclass. But what happens if we try to do just <span class="fixed">read "4"</span>?</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; read "4"
&lt;interactive&gt;:1:0:
    Ambiguous type variable `a' in the constraint:
      `Read a' arising from a use of `read' at &lt;interactive&gt;:1:0-7
    Probable fix: add a type signature that fixes these type variable(s)
</pre>
<p>What GHCI is telling us here is that it doesn't know what we want in return. Notice that in the previous uses of <span class="fixed">read</span> we did something with the result afterwards. That way, GHCI could infer what kind of result we wanted out of our <span class="fixed">read</span>. If we used it as a boolean, it knew it had to return a <span class="fixed">Bool</span>. But now, it knows we want some type that is part of the <span class="fixed">Read</span> class, it just doesn't know which one. Let's take a look at the type signature of <span class="fixed">read</span>.</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; :t read
read :: (Read a) =&gt; String -&gt; a
</pre>
<p>
See? It returns a type that's part of <span class="fixed">Read</span> but if we don't try to use it in some way later, it has no way of knowing which type. That's why we can use explicit <em>type annotations</em>. Type annotations are a way of explicitly saying what the type of an expression should be. We do that by adding <span class="fixed">::</span> at the end of the expression and then specifying a type. Observe:
</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; read "5" :: Int
5
ghci&gt; read "5" :: Float
5.0
ghci&gt; (read "5" :: Float) * 4
20.0
ghci&gt; read "[1,2,3,4]" :: [Int]
[1,2,3,4]
ghci&gt; read "(3, 'a')" :: (Int, Char)
(3, 'a')
</pre>
<p>Most expressions are such that the compiler can infer what their type is by itself. But sometimes, the compiler doesn't know whether to return a value of type <span class="fixed">Int</span> or <span class="fixed">Float</span> for an expression like <span class="fixed">read "5"</span>. To see what the type is, Haskell would have to actually evaluate <span class="fixed">read "5"</span>. But since Haskell is a statically typed language, it has to know all the types before the code is compiled (or in the case of GHCI, evaluated). So we have to tell Haskell: "Hey, this expression should have this type, in case you don't know!".</p>
<p><span class="label class">Enum</span> members are sequentially ordered types — they can be enumerated. The main advantage of the <span class="fixed">Enum</span> typeclass is that we can use its types in list ranges. They also have defined successors and predecesors, which you can get with the <span class="fixed">succ</span> and <span class="fixed">pred</span> functions. Types in this class: <span class="fixed">()</span>, <span class="fixed">Bool</span>, <span class="fixed">Char</span>, <span class="fixed">Ordering</span>, <span class="fixed">Int</span>, <span class="fixed">Integer</span>, <span class="fixed">Float</span> and <span class="fixed">Double</span>.</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; ['a'..'e']
"abcde"
ghci&gt; [LT .. GT]
[LT,EQ,GT]
ghci&gt; [3 .. 5]
[3,4,5]
ghci&gt; succ 'B'
'C'
</pre>
<p><span class="label class">Bounded</span> members have an upper and a lower bound.</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; minBound :: Int
-2147483648
ghci&gt; maxBound :: Char
'\1114111'
ghci&gt; maxBound :: Bool
True
ghci&gt; minBound :: Bool
False
</pre>
<p><span class="fixed">minBound</span> and <span class="fixed">maxBound</span> are interesting because they have a type of <span class="fixed">(Bounded a) =&gt; a</span>. In a sense they are polymorphic constants.</p>
<p>All tuples are also part of <span class="fixed">Bounded</span> if the components are also in it.</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; maxBound :: (Bool, Int, Char)
(True,2147483647,'\1114111')
</pre>
<p><span class="label class">Num</span> is a numeric typeclass. Its members have the property of being able to act like numbers. Let's examine the type of a number.</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; :t 20
20 :: (Num t) =&gt; t
</pre>
<p>It appears that whole numbers are also polymorphic constants. They can act like any type that's a member of the <span class="fixed">Num</span> typeclass.</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; 20 :: Int
20
ghci&gt; 20 :: Integer
20
ghci&gt; 20 :: Float
20.0
ghci&gt; 20 :: Double
20.0
</pre>
<p>Those are types that are in the <span class="fixed">Num</span> typeclass. If we examine the type of <span class="fixed">*</span>, we'll see that it accepts all numbers.</p>
<pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; :t (*)
(*) :: (Num a) =&gt; a -&gt; a -&gt; a
</pre>
<p>
It takes two numbers of the same type and returns a number of that type. That's why <span class="fixed">(5 :: Int) * (6 :: Integer)</span> will result in a type error whereas <span class="fixed">5 * (6 :: Integer)</span> will work just fine and produce an <span class="fixed">Integer</span> because <span class="fixed">5</span> can act like an <span class="fixed">Integer</span> or an <span class="fixed">Int</span>.
</p>
<p>To join <span class="fixed">Num</span>, a type must already be friends with <span class="fixed">Show</span> and <span class="fixed">Eq</span>.</p>
<p><span class="class label">Integral</span> is also a numeric typeclass. <span class="fixed">Num</span> includes all numbers, including real numbers and integral numbers, <span class="fixed">Integral</span> includes only integral (whole) numbers. In this typeclass are <span class="fixed">Int</span> and <span class="fixed">Integer</span>.</p>
<p><span class="class label">Floating</span> includes only floating point numbers, so <span class="fixed">Float</span> and <span class="fixed">Double</span>.</p>
<p>A very useful function for dealing with numbers is <span class="label function">fromIntegral</span>. It has a type declaration of <span class="fixed">fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b</span>. From its type signature we see that it takes an integral number and turns it into a more general number. That's useful when you want integral and floating point types to work together nicely. For instance, the <span class="fixed">length</span> function has a type declaration of <span class="fixed">length :: [a] -&gt; Int</span> instead of having a more general type of <span class="fixed">(Num b) =&gt; length :: [a] -&gt; b</span>. I think that's there for historical reasons or something, although in my opinion, it's pretty stupid. Anyway, if we try to get a length of a list and then add it to <span class="fixed">3.2</span>, we'll get an error because we tried to add together an <span class="fixed">Int</span> and a floating point number. So to get around this, we do <span class="fixed">fromIntegral (length [1,2,3,4]) + 3.2</span> and it all works out.</p>
<p>Notice that <span class="fixed">fromIntegral</span> has several class constraints in its type signature. That's completely valid and as you can see, the class constraints are separated by commas inside the parentheses.</p>

                <div class="footdiv">
                <ul>
                    <li style="text-align:left">
                                                        <a href="./starting-out" class="prevlink">Starting Out</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="./chapters">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="./syntax-in-functions" class="nxtlink">Syntax in Functions</a>
                                            </li>
                </ul>
            </div>
        </div>
    <script type="text/javascript" src="./files/shCore.js"></script>
    <script type="text/javascript" src="./files/shBrushHaskell.js"></script>
    <script type="text/javascript" src="./files/shBrushPlain.js"></script>
    <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script>
</div>


</body></html>
