<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0050)http://learnyouahaskell.com/higher-order-functions -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Higher Order Functions - Learn You a Haskell for Great Good!</title>

<!--<base href="http://learnyouahaskell.com/">--><base href=".">
<style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style>
<link rel="shortcut icon" href="http://learnyouahaskell.com/favicon.png" type="image/png">
        <link rel="prev" href="http://learnyouahaskell.com/recursion">
        <link rel="next" href="http://learnyouahaskell.com/modules">
<link type="text/css" rel="stylesheet" href="./files/SyntaxHighlighter.css">
<link href="http://learnyouahaskell.com/rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
<style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style><style type="text/css">.dp-hs .syntax_operators { color: #8ac6f2; }.dp-hs .common_operators { color: #8ac6f2; }</style></head>
<body class="introcontent">
<div class="bgwrapper">
    <div id="content">
                <div class="footdiv" style="margin-bottom:25px;">
                <ul>
                    <li style="text-align:left">
                                                        <a href="./recursion.html" class="prevlink">Recursion</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="./chapters.html">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="./modules.html" class="nxtlink">Modules</a>
                                            </li>
                </ul>
            </div>
        <h1 style="margin-left:-3px">고차원 함수</h1>
<img src="./files/sun.png" alt="sun" class="right" width="203" height="183">
<p>하스켈에서 함수들은 인자로 함수를 받거나 반환 값으로 함수를 반환하는 것이 가능합니다. 이처럼 함수를 인자로 받거나 반환하는 함수를 고차원 함수(higher order function)라고 부르죠. 이런 고차원 함수는 하스켈에서 굉장히 자주 등장하고 아주 중요합니다. 절차형 언어들처럼 변수에 저장된 값 등의 상태를 변경하는 일련의 단계나 루프를 정의하는 식으로 문제를 <i>어떻게</i> 해결할 지를 고민하는 것이 아니라 풀고자 하는 문제가 <i>무엇</i>인지를 고민하고자 한다면 고차원 함수는 필수 불가결한 개념입니다. 고차원 함수는 문제를 해결하고 프로그램에 대해 고민하는 아주 강력한 방법입니다. [[They're a really powerful way of solving problems and thinking about programs.]](이게 뭔소리여..)</p>
<a name="curried-functions"></a><h2>커리 함수</h2>
<p>하스켈의 모든 함수는 공식적으로는 단 하나의 인자만 받습니다. 하지만 여태까지 여러 개의 인자를 받는 함수를 잘 만들고 사용해 왔습니다. 어떻게 된 일일까요? 여기엔 아주 영리한 트릭이 숨어 있습니다. <i>여러 개의 인자</i>를 받는 함수는 모두 <em>커리 함수(curried function)</em>이었습니다. 커리 함수를 이해하기 위해 <span class="fixed">max</span> 함수를 예로 들어 봅시다. 겉보기에 이 함수는 두 개의 인자를 받고, 그 중 큰 값을 반환하는 것처럼 보입니다. 하지만 실제로는 <span class="fixed">max 4 5</span>를 실행하면 <span class="fixed">max 4</span>가 먼저 실행되고, 그 결과로 하나의 인자를 받아서 4와 비교해 큰 값을 반환하는 <i>함수</i>가 반환되고, 이렇게 만들어진 함수에 5가 적용되어 최종 결과가 나오게 됩니다. 조금 장황하고 복잡하게 들리지만 알고보면 아주 멋진 개념입니다. 아래의 두 함수 호출은 완전히 동일한 의미입니다.</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; max 4 5
5
ghci&gt; (max 4) 5
5
</pre>
<img src="./files/curry.png" alt="haskell curry" class="left" width="160" height="238">
<p>두 개의 식 사이에 공백을 주는 것은 그냥 <b>함수 실행</b>일 뿐입니다. 그래서 이 공백은 가장 높은 우선순위를 갖는 일종의 연산자라고도 할 수 있습니다. <span class="fixed">max</span>의 타입을 찬찬히 살펴봅시다. <span class="fixed">max :: (Ord a) =&gt; a -&gt; a -&gt; a</span>군요. 이 타입은 <span class="fixed">max :: (Ord a) =&gt; a -&gt; (a -&gt; a)</span> 라고도 쓸 수 있습니다. 이 타입을 꼼꼼히 읽어보면, <span class="fixed">max</span>는 <span class="fixed">a</span>를 받아 함수를 반환(<span class="fixed">-&gt;</span>가 의미하는 바에 따라)하고, 여기서 반환된 함수는 <span class="fixed">a</span>를 받아 <span class="fixed">a</span>를 반환하는 함수임을 나타내고 있습니다. 그래서 하스켈의 타입 식은 다른 언어들에서처럼 콤마 등이 등장하지 않고 간단하게 화살표로만 구분되어 표시될 수 있는 것입니다.</p>
<p>그런데 이게 무슨 도움이 될까요? 만약 함수에 정의된 것보다 적은 수의 인자만 주고 함수를 실행시키면 <em>부분적으로 실행된(partially applied)</em> 함수, 즉 남은 인자를 추가로 받아서 계산을 완료할 수 있는 함수가 반환됩니다. 이런 특징을 이용하면 다른 함수에 전해주거나 데이터를 수정할 함수를 즉석에서 만들 수 있습니다.</p>
<p>엄청나게 간단한 함수가 하나 있습니다.</p>
<pre name="code" class="haskell:ghci" style="display: none;">multThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a
multThree x y z = x * y * z
</pre>
<p><span class="fixed">multThree 3 5 9</span> 나 <span class="fixed">((multThree 3) 5) 9</span> 를 실행하면 무슨 일이 벌어질까요? 우선, <span class="fixed">3</span> 이 <span class="fixed">multThree</span>에 전달되어 실행됩니다(공백으로 구분되어 있기 때문에). 그러면 하나의 인자를 받아 함수를 반환하는 함수가 만들어지겠죠. 그 함수에는 <span class="fixed">5</span>가 적용되어 실행되고, 그 결과로 인자를 하나 받아 15와 곱해 반환하는 함수가 만들어집니다. 마지막으로 <span class="fixed">9</span> 가 함수에 적용되면 135의 결과가 나오게 됩니다. 이 함수의 타입은 <span class="fixed">multThree :: (Num a) =&gt; a -&gt; (a -&gt; (a -&gt; a))</span>임을 기억하세요. <span class="fixed">-&gt;</span> 앞에 나오는 것은 함수가 받을 인자이고, 뒤에 나오는 것은 함수가 반환하는 값입니다. 즉, <span class="fixed">multThree</span> 함수는 <span class="fixed">a</span> 타입의 값을 받아 <span class="fixed">(Num a) =&gt; a -&gt; (a -&gt; a)</span> 타입의 함수를 반환하는 함수인 것입니다. 비슷한 방식으로 이 함수는 <span class="fixed">a</span>를 받아 <span class="fixed">(Num a) =&gt; a -&gt; a</span> 타입의 함수를 반환하게 됩니다. 마찬가지로 이 함수는 <span class="fixed">a</span>를 받아 <span class="fixed">a</span>를 반환합니다. 다음 코드를 보시죠.</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; let multTwoWithNine = multThree 9
ghci&gt; multTwoWithNine 2 3
54
ghci&gt; let multWithEighteen = multTwoWithNine 2
ghci&gt; multWithEighteen 10
180
</pre>
<p>인자를 3개 받는 함수에 인자를 그보다 적은 1개 혹은 2개만 주면 그 자체로 새로운 함수가 만들어집니다. 만약 숫자를 하나 받아 <span class="fixed">100</span>과 비교하는 함수를 만들고자 한다면 이렇게 할 수 있습니다.</p>
<pre name="code" class="haskell:hs" style="display: none;">compareWithHundred :: (Num a, Ord a) =&gt; a -&gt; Ordering
compareWithHundred x = compare 100 x
</pre>
<p>이 함수를 <span class="fixed">99</span>라는 값을 주어 호출하면, <span class="fixed">GT</span>가 반환됩니다. 참 쉽죠? 그런데 여기서 양변에 모두 <span class="fixed">x</span> 가 보입니다. 여기서 <span class="fixed">compare 100</span>이 무엇을 반환하는지 생각해 봅시다. <span class="fixed">compare 100</span>은 숫자를 받아 <span class="fixed">100</span>과 비교하는 함수를 반환하죠. 아! 우리가 원래 원하던 것인 것 같죠? 그래서 이 코드는 다음과 같이 보다 간단히 쓸 수 있습니다.</p>
<pre name="code" class="haskell:hs" style="display: none;">compareWithHundred :: (Num a, Ord a) =&gt; a -&gt; Ordering
compareWithHundred = compare 100
</pre>
<p><span class="fixed">compare 100</span>가 함수를 반환하는 것이 바뀌지 않았기 때문에 타입 선언은 바뀌지 않았습니다. <span class="fixed">compare</span>는 <span class="fixed">(Ord a) =&gt; a -&gt; (a -&gt; Ordering)</span>의 타입을 갖고, 이 함수를 <span class="fixed">100</span>으로 호출하면 <span class="fixed">(Num a, Ord a) =&gt; a -&gt; Ordering</span>을 반환합니다. <span class="fixed">100</span>이 <span class="fixed">Num</span> 타입 클래스에 속하기 때문에 클래스 조건식이 조금 복잡해졌습니다.</p>
<div class="hintbox"><em>잠깐!</em> 커리 함수와 부분 실행이 어떻게 동작하는지 확실히 이해하고 넘어가세요! 이 부분은 정말 중요합니다!</div>
<p>infix 함수 역시 비슷한 방식으로 일부 인자만 주어 부분적으로 실행하는 것이 가능합니다. infix 함수에 인자 하나만 주고자 한다면 간단히 식을 괄호로 묶고 인자를 한쪽에만 써주면 됩니다. 그러면 쓰지 않은 쪽의 인자를 받아 infix 함수를 실행해 주는 함수를 반환하죠. 간단한 예제를 하나 보겠습니다.</p>
<pre name="code" class="haskell:hs" style="display: none;">divideByTen :: (Floating a) =&gt; a -&gt; a
divideByTen = (/10)
</pre>
<p>위의 정의에 의해 <span class="fixed">divideByTen 200</span>는 <span class="fixed">200 / 10</span>를 실행하는 것과 같고, <span class="fixed">(/10) 200</span> 라고 써도 동일한 의미입니다. 이번에는 알파벳 하나를 받아 받은 알파벳이 대문자인지 확인하는 함수를 만들어 보겠습니다.</p>
<pre name="code" class="haskell:hs" style="display: none;">isUpperAlphanum :: Char -&gt; Bool
isUpperAlphanum = (`elem` ['A'..'Z'])
</pre>
<p>단, <span class="fixed">-</span>을 사용할 때는 주의해야 합니다. infix 함수의 부분 실행 문법에 따르면 <span class="fixed">(-4)</span>는 숫자를 하나 받아 거기서 4를 빼서 반환하는 함수가 됩니다. 하지만 하스켈은 편의를 위해 <span class="fixed">(-4)</span>를 숫자 -4로 해석합니다. 만약 숫자를 하나 받아 4를 빼는 함수를 만들고자 한다면 <span class="fixed">subtract</span> 함수를 이용해 <span class="fixed">(subtract 4)</span>와 같이 적어야 합니다.</p>
<p>만약 GHCi에서 <span class="fixed">multThree 3 4</span>라는 식을 <i>let</i>으로 이름을 붙여주거나 다른 함수에 인자로 넘기지 않고 그냥 실행시키면 어떻게 될까요?</p>
<pre name="code" class="haskell:hs" style="display: none;">ghci&gt; multThree 3 4
&lt;interactive&gt;:1:0:
    No instance for (Show (t -&gt; t))
      arising from a use of `print' at &lt;interactive&gt;:1:0-12
    Possible fix: add an instance declaration for (Show (t -&gt; t))
    In the expression: print it
    In a 'do' expression: print it
</pre>
<p>GHCi의 오류 메시지는 우리가 입력한 식이 <span class="fixed">a -&gt; a</span>의 타입을 갖고 있어서 화면에 어떻게 표시해야 할 지 알 수 없다고 말하고 있습니다. 함수는 <span class="fixed">Show</span> 타입클래스에 속하지 않기 때문에, 화면에 표시할 수 있도록 문자열로 변환하는 기능이 제공되지 않습니다. GHCi에서 <span class="fixed">1 + 1</span>를 실행하면 GHCi는 우선 이 식을 계산해서 <span class="fixed">2</span>라는 값을 얻어내고 계산된 값 <span class="fixed">2</span>에 대해 <span class="fixed">show</span> 함수를 호출해서 화면에 표시할 수 있는 문자열 형태로 변환합니다. <span class="fixed">2</span>의 문자열 형태는 문자열 <span class="fixed">"2"</span>이기 때문에 화면에 그대로 표시됩니다.</p>
<a name="higher-orderism"></a><h2>Some higher-orderism is in order</h2>
<p>함수는 함수를 인자로 받을 수도 있고 함수를 반환할 수도 있습니다. 함수를 인자로 받아 이 함수를 두 번 실행하는 함수를 보시겠습니다.</p>
<pre name="code" class="haskell:hs" style="display: none;">applyTwice :: (a -&gt; a) -&gt; a -&gt; a
applyTwice f x = f (f x)
</pre>
<img src="./files/bonus.png" alt="rocktopus" class="right" width="166" height="190">
<p>우선 이 함수의 타입 정의를 주목하세요. 타입 표현에서는 기본적으로 <span class="fixed">-&gt;</span>가 right-associative하기 때문에 지금까지는 함수의 타입을 쓸 때 특별히 괄호를 쓰지 않았습니다. 하지만 <span class="fixed">applyTwice</span>의 타입을 표현할 때 괄호는 필수입니다. 그래야 이 함수의 첫번째 인자가 타입 <span class="fixed">a</span>의 값을 하나 받아 타입 <span class="fixed">a</span>의 값을 반환하는 함수라는 것을 나타낼 수 있기 때문입니다. 두번째 인자 역시 <span class="fixed">a</span> 타입의 값이고, 반환하는 값도 <span class="fixed">a</span> 타입의 값입니다. 이런 타입 정의를 커리 식으로 읽을 수도 있지만, 너무 복잡하기 때문에, 그냥 이 함수는 두 개의 인자를 받아 어떤 값을 반환하는 함수라고 표현할 것입니다. 이 경우, 이 함수의 첫번째 인자는 <span class="fixed">a -&gt; a</span> 타입의 함수이고, 두번째 인자는 앞서 등장한 <span class="fixed">a</span>와 같은 타입이라고 할 수 있습니다. 이 함수의 첫번째 인자로 <span class="fixed">Int -&gt; Int</span> 타입의 함수든 <span class="fixed">String -&gt; String</span> 타입의 함수든 줄 수 있지만 두번째 인자가 같은 타입이 되어야 할 것입니다.</p>
<div class="hintbox"><em>Note:</em> 하스켈에서는 함수의 인자가 모두 결정되어 최종 계산값이 나오기 전까지는 함수가 단 하나의 인자를 받아 부분적으로 실행된 함수를 반환합니다. 하지만 앞으로는 그냥 함수가 여러 개의 인자를 받는다고 표현할 것입니다. 그렇게 하는 편이 더 간단하기 때문입니다. 예를 들면 <span class="fixed">a -&gt; a -&gt; a</span> 타입의 함수는 실제로는 다르게 동작하는 것을 알지만, 그냥 두 개의 인자를 받는다고 표현할 것입니다.</div>
<p>
함수의 내용은 꽤 간단합니다. 그냥 인자로 받은 <span class="fixed">f</span> 를 함수처럼 사용해서 띄어쓰기로 구분해 <span class="fixed">x</span>를 인자로 주어 <span class="fixed">f</span>를 실행하고, 그 결과를 다시 <span class="fixed">f</span>에 전달해 실행하고 있습니다. 몇가지 사용예를 볼까요.
</p>
<pre name="code" class="haskell:hs" style="display: none;">ghci&gt; applyTwice (+3) 10
16
ghci&gt; applyTwice (++ " HAHA") "HEY"
"HEY HAHA HAHA"
ghci&gt; applyTwice ("HAHA " ++) "HEY"
"HAHA HAHA HEY"
ghci&gt; applyTwice (multThree 2 2) 9
144
ghci&gt; applyTwice (3:) [1]
[3,3,1]
</pre>
<p>
부분 실행의 아름다움과 유용성은 명백합니다. 만약 어떤 함수가 인자를 하나 받는 함수를 필요로 하면 함수에 인자를 하나만 남기고 실행해서 하나의 인자를 받는 부분 실행 함수를 넘겨줄 수 있습니다.
</p>
<p>
이번에는 표준 라이브러리에도 포함된 실제로 유용한 함수 하나를 고차원 함수를 이용해 만들어 보겠습니다. <span class="fixed">zipWith</span>라는 함수인데요, 이 함수는 함수 하나와 두 개의 리스트를 인자로 받고, 두 리스트에서 대응되는 값 두개를 함수에 넘겨서 나온 값들로 하나의 리스트로 결합하는 함수입니다. 이 함수의 구현을 보시죠.</p>
<pre name="code" class="haskell:hs" style="display: none;">zipWith' :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
</pre>
<p>타입 정의부터 보시겠습니다. 첫번째 인자는 두 개의 값을 받고 하나의 값을 반환하는 함수입니다. 인자로 받는 두 개의 값의 타입과 반환하는 값의 타입은 모두 같을 수도 있고, 모두 다를 수도 있습니다. 두번째 인자와 세번째 인자는 리스트이고, 반환하는 값도 리스트입니다. 두번째 인자로 받은 리스트는 <span class="fixed">a</span> 타입의 값을 갖는 리스트이고, 첫번째 인자인 함수가 받는 첫번째 인자와 같은 타입입니다. 세번째 인자로 받은 리스트는 <span class="fixed">b</span> 타입의 값을 갖는 리스트이고, 첫번째 인자인 함수가 받는 두번째 인자와 같은 타입니다. 함수의 결과는 첫번째 인자인 함수가 리턴하는 값의 타입인 <span class="fixed">c</span> 타입의 값들로 구성된 리스트입니다. 타입 정의에서 <span class="fixed">a -&gt; b -&gt; c</span> 함수를 인자로 받고 있는 경우에, <span class="fixed">a</span>, <span class="fixed">b</span>, <span class="fixed">c</span> 타입은 모두 같아도 됩니다. 즉, <span class="fixed">a -&gt; a -&gt; a</span> 함수도 받을 수 있다는 뜻이죠. 하지만 그 반대는 불가능합니다. 함수를 만들 때, 특히 고차원 함수를 만들 때, 타입을 정확히 모르겠으면 그냥 타입 정의를 쓰지 않고 <span class="fixed">:t</span>를 이용해서 하스켈이 함수의 타입이 뭐라고 추론하는지 볼 수 있다는 것을 기억하세요.
</p>
<p>함수의 동작은 <span class="fixed">zip</span>과도 비슷합니다. 두 리스트 중 하나가 비어있으면 함수가 종료된는 경계 조건(edge condition)은 동일하지만, 조합 함수가 함수의 인자로 추가되어 있다는 점이 다릅니다. 하지만 경계 조건에 영향을 미치는 값이 아니기 때문에 그냥 <span class="fixed">_</span>를 사용했습니다. 함수 정의의 마지막 패턴 역시 <span class="fixed">zip</span>과 유사합니다. 하지만 <span class="fixed">zip</span>에서는 두 리스트에서 얻어온 값을 단순히 <span class="fixed">(x,y)</span>로 조합했던 것과 달리 <span class="fixed">f x y</span>를 사용하고 있습니다. [[A single higher order function can be used for a multitude of different tasks if it's general enough. 뭔소리지..]] 우리가 만든 <span class="fixed">zipWith'</span>를 사용하는 방법을 보겠습니다.</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; zipWith' (+) [4,2,5,6] [2,6,2,3]
[6,8,7,9]
ghci&gt; zipWith' max [6,3,2,1] [7,3,1,5]
[7,3,2,5]
ghci&gt; zipWith' (++) ["foo ", "bar ", "baz "] ["fighters", "hoppers", "aldrin"]
["foo fighters","bar hoppers","baz aldrin"]
ghci&gt; zipWith' (*) (replicate 5 2) [1..]
[2,4,6,8,10]
ghci&gt; zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]
[[3,4,6],[9,20,30],[10,12,12]]
</pre>
<p>
보시는 바와 같이, 고차원 함수는 정말 다양한 용도로 사용할 수 있습니다. 절차형 언어에서는 무언가를 구현하기 위해 for 루프, while 루프, 변수에 값 설정, 상태 확인 등등의 기능들을 이용하고 이것들을 함수와 같은 인터페이스로 감싸곤 합니다. 함수형 프로그래밍은 고차원 함수를 만들어 공통적인 패턴을 추상화합니다. [[like examining two lists in pairs and doing something with those pairs or getting a set of solutions and eliminating the ones you don't need. 이것도 뭔지 모르겠다..]]
</p>
<p>
이번에는 표준 라이브러리에 포함된 함수인 <span class="fixed">flip</span>을 구현해 보겠습니다. 이 함수는 다른 함수를 하나 받아 첫번째 인자와 두번째 인자의 순서를 바꾸는 역할을 합니다. 실제 함수의 구현은 이렇습니다.
</p>
<pre name="code" class="haskell:hs" style="display: none;">flip' :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)
flip' f = g
    where g x y = f y x
</pre>
<p>
타입 정의를 보면, 이 함수는 <span class="fixed">a</span> 타입의 인자와 <span class="fixed">b</span> 타입의 인자, 총 두 개의 인자를 받아 <span class="fixed">c</span> 타입의 값을 반환하는 함수를 하나 받아, <span class="fixed">b</span> 타입의 인자와 <span class="fixed">a</span> 타입의 인자를 받아 <span class="fixed">c</span> 타입의 값을 반환하는 함수를 반환합니다. 사실 이 타입 정의에서 <span class="fixed">-&gt;</span> 가 본래 right-associative 하기 때문에 <span class="fixed">(a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)</span> 와 <span class="fixed">(a -&gt; b -&gt; c) -&gt; (b -&gt; (a -&gt; c))</span> 와 <span class="fixed">(a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</span> 는 모두 완전히 동일한 의미이므로 두번째 괄호는 불필요합니다만 가독성을 위해 쓴 것입니다. 여기서는 <span class="fixed">g x y = f y x</span> 라고 적었는데, 이 조건을 만족하면 <span class="fixed">f y x = g x y</span> 도 성립해야 합니다. 그래서 이 함수는 보다 단순하게 이렇게 쓸 수도 있습니다:</p>
<pre name="code" class="haskell:hs" style="display: none;">flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
flip' f y x = f x y
</pre>
<p>
이렇게 하면 함수들이 커리되어있다는 특징을 보다 잘 활용할 수 있습니다. <span class="fixed">flip'</span> 함수가 인자로 받아야 하는 <span class="fixed">y</span>와 <span class="fixed">x</span> 없이 <span class="fixed">flip' f</span>라고 호출하면 두 개의 인자 <span class="fixed">y</span>와 <span class="fixed">x</span>를 받아 두 인자의 순서를 뒤집어 <span class="fixed">f</span>를 호출하는 함수를 반환하게 됩니다. 순서가 뒤바뀐 함수는 대체로 다른 함수에 인자로 사용되는 경우가 많지만, [[we can take advantage of currying when making higher-order functions by thinking ahead and writing what their end result would be if they were called fully applied 이건 또 뭔소리냐...]].</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; flip' zip [1,2,3,4,5] "hello"
[('h',1),('e',2),('l',3),('l',4),('o',5)]
ghci&gt; zipWith (flip' div) [2,2..] [10,8,6,4,2]
[5,4,3,2,1]
</pre>
<a name="maps-and-filters"></a><h2>Maps and filters</h2>
<p><span class="function label">map</span> takes a function and a list and applies that function to every element in the list, producing a new list. Let's see what its type signature is and how it's defined.</p>
<pre name="code" class="haskell:hs" style="display: none;">map :: (a -&gt; b) -&gt; [a] -&gt; [b]
map _ [] = []
map f (x:xs) = f x : map f xs
</pre>
<p>The type signature says that it takes a function that takes an <span class="fixed">a</span> and returns a <span class="fixed">b</span>, a list of <span class="fixed">a</span>'s and returns a list of <span class="fixed">b</span>'s. It's interesting that just by looking at a function's type signature, you can sometimes tell what it does. <span class="fixed">map</span> is one of those really versatile higher-order functions that can be used in millions of different ways. Here it is in action:</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; map (+3) [1,5,3,1,6]
[4,8,6,4,9]
ghci&gt; map (++ "!") ["BIFF", "BANG", "POW"]
["BIFF!","BANG!","POW!"]
ghci&gt; map (replicate 3) [3..6]
[[3,3,3],[4,4,4],[5,5,5],[6,6,6]]
ghci&gt; map (map (^2)) [[1,2],[3,4,5,6],[7,8]]
[[1,4],[9,16,25,36],[49,64]]
ghci&gt; map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]
[1,3,6,2,2]
</pre>
<p>You've probably noticed that each of these could be achieved with a list comprehension. <span class="fixed">map (+3) [1,5,3,1,6]</span> is the same as writing <span class="fixed">[x+3 | x &lt;- [1,5,3,1,6]]</span>. However, using <span class="fixed">map</span> is much more readable for cases where you only apply some function to the elements of a list, especially once you're dealing with maps of maps and then the whole thing with a lot of brackets can get a bit messy.</p>
<p><span class="label function">filter</span> is a function that takes a predicate (a predicate is a function that tells whether something is true or not, so in our case, a function that returns a boolean value) and a list and then returns the list of elements that satisfy the predicate. The type signature and implementation go like this:</p> 
<pre name="code" class="haskell:hs" style="display: none;">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
filter _ [] = []
filter p (x:xs) 
    | p x       = x : filter p xs
    | otherwise = filter p xs
</pre>
<p>Pretty simple stuff. If <span class="fixed">p x</span> evaluates to <span class="fixed">True</span>, the element gets included in the new list. If it doesn't, it stays out. Some usage examples:</p>
<pre name="code" class="haskell:hs" style="display: none;">ghci&gt; filter (&gt;3) [1,5,3,2,1,6,4,3,2,1]
[5,6,4]
ghci&gt; filter (==3) [1,2,3,4,5]
[3]
ghci&gt; filter even [1..10]
[2,4,6,8,10]
ghci&gt; let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
[[1,2,3],[3,4,5],[2,2]]
ghci&gt; filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent"
"uagameasadifeent"
ghci&gt; filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"
"GAYBALLS"
</pre>
<p>All of this could also be achived with list comprehensions by the use of predicates. There's no set rule for when to use <span class="fixed">map</span> and <span class="fixed">filter</span> versus using list comprehension, you just have to decide what's more readable depending on the code and the context. The <span class="fixed">filter</span> equivalent of applying several predicates in a list comprehension is either filtering something several times or joining the predicates with the logical <span class="fixed">&amp;&amp;</span> function. </p>
<p>Remember our quicksort function from the <a href="http://learnyouahaskell.com/recursion">previous chapter</a>? We used list comprehensions to filter out the list elements that are smaller than (or equal to) and larger than the pivot. We can achieve the same functionality in a more readable way by using <span class="fixed">filter</span>:</p>
<pre name="code" class="haskell:ghci" style="display: none;">quicksort :: (Ord a) =&gt; [a] -&gt; [a]  
quicksort [] = []  
quicksort (x:xs) =   
    let smallerSorted = quicksort (filter (&lt;=x) xs)
        biggerSorted = quicksort (filter (&gt;x) xs) 
    in  smallerSorted ++ [x] ++ biggerSorted
</pre>
<img src="./files/map.png" alt="map" class="left" width="210" height="115">
<p>Mapping and filtering is the bread and butter of every functional programmer's toolbox. Uh. It doesn't matter if you do it with the <span class="fixed">map</span> and <span class="fixed">filter</span> functions or list comprehensions. Recall how we solved the problem of finding right triangles with a certain circumference. With imperative programming, we would have solved it by nesting three loops and then testing if the current combination satisfies a right triangle and if it has the right perimeter. If that's the case, we would have printed it out to the screen or something. In functional programming, that pattern is achieved with mapping and filtering. You make a function that takes a value and produces some result. We map that function over a list of values and then we filter the resulting list out for the results that satisfy our search. Thanks to Haskell's laziness, even if you map something over a list several times and filter it several times, it will only pass over the list once.</p>
<p>Let's <em>find the largest number under 100,000 that's divisible by 3829</em>. To do that, we'll just filter a set of possibilities in which we know the solution lies. </p>
<pre name="code" class="haskell:hs" style="display: none;">largestDivisible :: (Integral a) =&gt; a
largestDivisible = head (filter p [100000,99999..])
    where p x = x `mod` 3829 == 0
</pre>
<p>We first make a list of all numbers lower than 100,000, descending. Then we filter it by our predicate and because the numbers are sorted in a descending manner, the largest number that satisfies our predicate is the first element of the filtered list. We didn't even need to use a finite list for our starting set. That's laziness in action again. Because we only end up using the head of the filtered list, it doesn't matter if the filtered list is finite or infinite. The evaluation stops when the first adequate solution is found.</p>
<p>Next up, we're going to <em>find the sum of all odd squares that are smaller than 10,000</em>. But first, because we'll be using it in our solution, we're going to introduce the <span class="label function">takeWhile</span> function. It takes a predicate and a list and then goes from the beginning of the list and returns its elements while the predicate holds true. Once an element is found for which the predicate doesn't hold, it stops. If we wanted to get the first word of the string <span class="fixed">"elephants know how to party"</span>, we could do <span class="fixed">takeWhile (/=' ') "elephants know how to party"</span> and it would return <span class="fixed">"elephants"</span>. Okay. The sum of all odd squares that are smaller than 10,000. First, we'll begin by mapping the <span class="fixed">(^2)</span> function to the infinite list <span class="fixed">[1..]</span>. Then we filter them so we only get the odd ones. And then, we'll take elements from that list while they are smaller than 10,000. Finally, we'll get the sum of that list. We don't even have to define a function for that, we can do it in one line in GHCI:</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; sum (takeWhile (&lt;10000) (filter odd (map (^2) [1..])))
166650
</pre>
<p>Awesome! We start with some initial data (the infinite list of all natural numbers) and then we map over it, filter it and cut it until it suits our needs and then we just sum it up. We could have also written this using list comprehensions:</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; sum (takeWhile (&lt;10000) [n^2 | n &lt;- [1..], odd (n^2)])
166650
</pre>
<p>It's a matter of taste as to which one you find prettier. Again, Haskell's property of laziness is what makes this possible. We can map over and filter an infinite list, because it won't actually map and filter it right away, it'll delay those actions. Only when we force Haskell to show us the sum does the <span class="fixed">sum</span> function say to the <span class="fixed">takeWhile</span> that it needs those numbers. <span class="fixed">takeWhile</span> forces the filtering and mapping to occur, but only until a number greater than or equal to 10,000 is encountered. </p>
<p>For our next problem, we'll be dealing with Collatz sequences. We take a natural number. If that number is even, we divide it by two. If it's odd, we multiply it by 3 and then add 1 to that. We take the resulting number and apply the same thing to it, which produces a new number and so on. In essence, we get a chain of numbers. It is thought that for all starting numbers, the chains finish at the number 1. So if we take the starting number 13, we get this sequence: <i>13, 40, 20, 10, 5, 16, 8, 4, 2, 1</i>. 13*3 + 1 equals 40. 40 divided by 2 is 20, etc. We see that the chain has 10 terms.</p>
<p>Now what we want to know is this: <em>for all starting numbers between 1 and 100, how many chains have a length greater than 15?</em> First off, we'll write a function that produces a chain:</p>
<pre name="code" class="haskell:hs" style="display: none;">chain :: (Integral a) =&gt; a -&gt; [a]
chain 1 = [1]
chain n
    | even n =  n:chain (n `div` 2)
    | odd n  =  n:chain (n*3 + 1)
</pre>
<p>Because the chains end at 1, that's the edge case. This is a pretty standard recursive function.</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; chain 10
[10,5,16,8,4,2,1]
ghci&gt; chain 1
[1]
ghci&gt; chain 30
[30,15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1]
</pre>
<p>Yay! It seems to be working correctly. And now, the function that tells us the answer to our question:</p>
<pre name="code" class="haskell:hs" style="display: none;">numLongChains :: Int
numLongChains = length (filter isLong (map chain [1..100]))
    where isLong xs = length xs &gt; 15
</pre>
<p>We map the <span class="fixed">chain</span> function to <span class="fixed">[1..100]</span> to get a list of chains, which are themselves represented as lists. Then, we filter them by a predicate that just checks whether a list's length is longer than 15. Once we've done the filtering, we see how many chains are left in the resulting list.</p>
<div class="hintbox"><em>Note:</em> This function has a type of <span class="fixed">numLongChains :: Int</span> because <span class="fixed">length</span> returns an <span class="fixed">Int</span> instead of a <span class="fixed">Num a</span> for historical reasons. If we wanted to return a more general <span class="fixed">Num a</span>, we could have used <span class="fixed">fromIntegral</span> on the resulting length.</div>
<p>Using <span class="fixed">map</span>, we can also do stuff like <span class="fixed">map (*) [0..]</span>, if not for any other reason than to illustrate how currying works and how (partially applied) functions are real values that you can pass around to other functions or put into lists (you just can't turn them to strings). So far, we've only mapped functions that take one parameter over lists, like <span class="fixed">map (*2) [0..]</span> to get a list of type <span class="fixed">(Num a) =&gt; [a]</span>, but we can also do <span class="fixed">map (*) [0..]</span> without a problem. What happens here is that the number in the list is applied to the function <span class="fixed">*</span>, which has a type of <span class="fixed">(Num a) =&gt; a -&gt; a -&gt; a</span>. Applying only one parameter to a function that takes two parameters returns a function that takes one parameter. If we map <span class="fixed">*</span> over the list <span class="fixed">[0..]</span>, we get back a list of functions that only take one parameter, so <span class="fixed">(Num a) =&gt; [a -&gt; a]</span>. <span class="fixed">map (*) [0..]</span> produces a list like the one we'd get by writing <span class="fixed">[(0*),(1*),(2*),(3*),(4*),(5*)..</span>.</p>
<pre name="code" class="haskell:hs" style="display: none;">ghci&gt; let listOfFuns = map (*) [0..]
ghci&gt; (listOfFuns !! 4) 5
20
</pre>
<p>Getting the element with the index <span class="fixed">4</span> from our list returns a function that's equivalent to <span class="fixed">(4*)</span>. And then, we just apply <span class="fixed">5</span> to that function. So that's like writing <span class="fixed">(4*) 5</span> or just <span class="fixed">4 * 5</span>.</p>
<a name="lambdas"></a><h2>Lambdas</h2>
<img src="./files/lambda.png" alt="lambda" class="right" width="203" height="230">
<p>Lambdas are basically anonymous functions that are used because we need some functions only once. Normally, we make a lambda with the sole purpose of passing it to a higher-order function. To make a lambda, we write a <span class="fixed">\</span> (because it kind of looks like the greek letter lambda if you squint hard enough) and then we write the parameters, separated by spaces. After that comes a <span class="fixed">-&gt;</span> and then the function body. We usually surround them by parentheses, because otherwise they extend all the way to the right.</p>
<p>If you look about 5 inches up, you'll see that we used a <i>where</i> binding in our <span class="fixed">numLongChains</span> function to make the <span class="fixed">isLong</span> function for the sole purpose of passing it to <span class="fixed">filter</span>. Well, instead of doing that, we can use a lambda:</p>
<pre name="code" class="haskell:hs" style="display: none;">numLongChains :: Int
numLongChains = length (filter (\xs -&gt; length xs &gt; 15) (map chain [1..100]))
</pre>
<p>Lambdas are expressions, that's why we can just pass them like that. The expression <span class="fixed">(\xs -&gt; length xs &gt; 15)</span> returns a function that tells us whether the length of the list passed to it is greater than 15.</p>
<img src="./files/lamb.png" alt="lamb" class="left" width="200" height="134">
<p>People who are not well acquainted with how currying and partial application works often use lambdas where they don't need to. For instance, the expressions <span class="fixed">map (+3) [1,6,3,2]</span> and <span class="fixed">map (\x -&gt; x + 3) [1,6,3,2]</span> are equivalent since both <span class="fixed">(+3)</span> and <span class="fixed">(\x -&gt; x + 3)</span> are functions that take a number and add 3 to it. Needless to say, making a lambda in this case is stupid since using partial application is much more readable.</p>
<p>Like normal functions, lambdas can take any number of parameters:</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; zipWith (\a b -&gt; (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]
[153.0,61.5,31.0,15.75,6.6]
</pre>
<p>And like normal functions, you can pattern match in lambdas. The only difference is that you can't define several patterns for one parameter, like making a <span class="fixed">[]</span> and a <span class="fixed">(x:xs)</span> pattern for the same parameter and then having values fall through. If a pattern matching fails in a lambda, a runtime error occurs, so be careful when pattern matching in lambdas!</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; map (\(a,b) -&gt; a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]
[3,8,9,8,7]
</pre>
<p>Lambdas are normally surrounded by parentheses unless we mean for them to extend all the way to the right. Here's something interesting: due to the way functions are curried by default, these two are equivalent:</p>
<pre name="code" class="haskell:ghci" style="display: none;">addThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a
addThree x y z = x + y + z
</pre>
<pre name="code" class="haskell:ghci" style="display: none;">addThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a
addThree = \x -&gt; \y -&gt; \z -&gt; x + y + z
</pre>
<p>If we define a function like this, it's obvious why the type declaration is what it is. There are three <span class="fixed">-&gt;</span>'s in both the type declaration and the equation. But of course, the first way to write functions is far more readable, the second one is pretty much a gimmick to illustrate currying.</p>
<p>However, there are times when using this notation is cool. I think that the <span class="fixed">flip</span> function is the most readable when defined like so:</p>
<pre name="code" class="haskell:ghci" style="display: none;">flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
flip' f = \x y -&gt; f y x
</pre>
<p>Even though that's the same as writing <span class="fixed">flip' f x y = f y x</span>, we make it obvious that this will be used for producing a new function most of the time. The most common use case with <span class="fixed">flip</span> is calling it with just the function parameter and then passing the resulting function on to a map or a filter. So use lambdas in this way when you want to make it explicit that your function is mainly meant to be partially applied and passed on to a function as a parameter.</p>
<a name="folds"></a><h2>Only folds and horses</h2>
<img src="./files/origami.png" alt="folded bird" class="right" width="220" height="221">
<p>Back when we were dealing with recursion, we noticed a theme throughout many of the recursive functions that operated on lists. Usually, we'd have an edge case for the empty list. We'd introduce the <span class="fixed">x:xs</span> pattern and then we'd do some action that involves a single element and the rest of the list. It turns out this is a very common pattern, so a couple of very useful functions were introduced to encapsulate it. These functions are called folds. They're sort of like the <span class="fixed">map</span> function, only they reduce the list to some single value. </p>
<p>A fold takes a binary function, a starting value (I like to call it the accumulator) and a list to fold up. The binary function itself takes two parameters. The binary function is called with the accumulator and the first (or last) element and produces a new accumulator. Then, the binary function is called again with the new accumulator and the now new first (or last) element, and so on. Once we've walked over the whole list, only the accumulator remains, which is what we've reduced the list to.</p>
<p>First let's take a look at the <span class="label function">foldl</span> function, also called the left fold. It folds the list up from the left side. The binary function is applied between the starting value and the head of the list. That produces a new accumulator value and the binary function is called with that value and the next element, etc.</p>
<p>Let's implement <span class="fixed">sum</span> again, only this time, we'll use a fold instead of explicit recursion.</p>
<pre name="code" class="haskell:hs" style="display: none;">sum' :: (Num a) =&gt; [a] -&gt; a
sum' xs = foldl (\acc x -&gt; acc + x) 0 xs
</pre>
<p>Testing, one two three:</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; sum' [3,5,2,1]
11
</pre>
<img src="./files/foldl.png" alt="foldl" class="left" width="172" height="348">
<p>Let's take an in-depth look into how this fold happens. <span class="fixed">\acc x -&gt; acc + x</span> is the binary function. <span class="fixed">0</span> is the starting value and <span class="fixed">xs</span> is the list to be folded up. Now first, <span class="fixed">0</span> is used as the <span class="fixed">acc</span> parameter to the binary function and <span class="fixed">3</span> is used as the <span class="fixed">x</span> (or the current element) parameter. <span class="fixed">0 + 3</span> produces a <span class="fixed">3</span> and it becomes the new accumulator value, so to speak. Next up, <span class="fixed">3</span> is used as the accumulator value and <span class="fixed">5</span> as the current element and <span class="fixed">8</span> becomes the new accumulator value. Moving forward, <span class="fixed">8</span> is the accumulator value, <span class="fixed">2</span> is the current element, the new accumulator value is <span class="fixed">10</span>. Finally, that <span class="fixed">10</span> is used as the accumulator value and <span class="fixed">1</span> as the current element, producing an <span class="fixed">11</span>. Congratulations, you've done a fold! </p>
<p>This professional diagram on the left illustrates how a fold happens, step by step (day by day!). The greenish brown number is the accumulator value. You can see how the list is sort of consumed up from the left side by the accumulator. Om nom nom nom! If we take into account that functions are curried, we can write this implementation ever more succinctly, like so:</p> 
<pre name="code" class="haskell:hs" style="display: none;">sum' :: (Num a) =&gt; [a] -&gt; a
sum' = foldl (+) 0
</pre>
<p>The lambda function <span class="fixed">(\acc x -&gt; acc + x)</span> is the same as <span class="fixed">(+)</span>. We can omit the <span class="fixed">xs</span> as the parameter because calling <span class="fixed">foldl (+) 0</span> will return a function that takes a list. Generally, if you have a function like <span class="fixed">foo a = bar b a</span>, you can rewrite it as <span class="fixed">foo = bar b</span>, because of currying.</p>
<p>Anyhoo, let's implement another function with a left fold before moving on to right folds. I'm sure you all know that <span class="fixed">elem</span> checks whether a value is part of a list so I won't go into that again (whoops, just did!). Let's implement it with a left fold. </p>
<pre name="code" class="haskell:hs" style="display: none;">elem' :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool
elem' y ys = foldl (\acc x -&gt; if x == y then True else acc) False ys
</pre>
<p>Well, well, well, what do we have here? The starting value and accumulator here is a boolean value. The type of the accumulator value and the end result is always the same when dealing with folds. Remember that if you ever don't know what to use as a starting value, it'll give you some idea. We start off with <span class="fixed">False</span>. It makes sense to use <span class="fixed">False</span> as a starting value. We assume it isn't there. Also, if we call a fold on an empty list, the result will just be the starting value. Then we check the current element is the element we're looking for. If it is, we set the accumulator to <span class="fixed">True</span>. If it's not, we just leave the accumulator unchanged. If it was <span class="fixed">False</span> before, it stays that way because this current element is not it. If it was <span class="fixed">True</span>, we leave it at that.</p>
<p>The right fold, <span class="function label">foldr</span> works in a similar way to the left fold, only the accumulator eats up the values from the right. Also, the left fold's binary function has the accumulator as the first parameter and the current value as the second one (so <span class="fixed">\acc x -&gt; ...</span>), the right fold's binary function has the current value as the first parameter and the accumulator as the second one (so <span class="fixed">\x acc -&gt; ...</span>). It kind of makes sense that the right fold has the accumulator on the right, because it folds from the right side.</p>
<p>The accumulator value (and hence, the result) of a fold can be of any type. It can be a number, a boolean or even a new list. We'll be implementing the map function with a right fold. The accumulator will be a list, we'll be accumulating the mapped list element by element. From that, it's obvious that the starting element will be an empty list.</p>
<pre name="code" class="haskell:hs" style="display: none;">map' :: (a -&gt; b) -&gt; [a] -&gt; [b]
map' f xs = foldr (\x acc -&gt; f x : acc) [] xs
</pre>
<p>If we're mapping <span class="fixed">(+3)</span> to <span class="fixed">[1,2,3]</span>, we approach the list from the right side. We take the last element, which is <span class="fixed">3</span> and apply the function to it, which ends up being <span class="fixed">6</span>. Then, we prepend it to the accumulator, which is was <span class="fixed">[]</span>. <span class="fixed">6:[]</span> is <span class="fixed">[6]</span> and that's now the accumulator. We apply <span class="fixed">(+3)</span> to <span class="fixed">2</span>, that's <span class="fixed">5</span> and we prepend (<span class="fixed">:</span>) it to the accumulator, so the accumulator is now <span class="fixed">[5,6]</span>. We apply <span class="fixed">(+3)</span> to <span class="fixed">1</span> and prepend that to the accumulator and so the end value is <span class="fixed">[4,5,6]</span>.</p>
<p>Of course, we could have implemented this function with a left fold too. It would be <span class="fixed">map' f xs = foldl (\acc x -&gt; acc ++ [f x]) [] xs</span>, but the thing is that the <span class="fixed">++</span> function is much more expensive than <span class="fixed">:</span>, so we usually use right folds when we're building up new lists from a list.</p>
<img src="./files/washmachine.png" alt="fold this up!" class="right" width="250" height="205">
<p>If you reverse a list, you can do a right fold on it just like you would have done a left fold and vice versa. Sometimes you don't even have to do that. The <span class="fixed">sum</span> function can be implemented pretty much the same with a left and right fold. One big difference is that right folds work on infinite lists, whereas left ones don't! To put it plainly, if you take an infinite list at some point and you fold it up from the right, you'll eventually reach the beginning of the list. However, if you take an infinite list at a point and you try to fold it up from the left, you'll never reach an end! </p>
<p><em>Folds can be used to implement any function where you traverse a list once, element by element, and then return something based on that. Whenever you want to traverse a list to return something, chances are you want a fold.</em> That's why folds are, along with maps and filters, one of the most useful types of functions in functional programming.</p> 
<p>The <span class="label function">foldl1</span> and <span class="label function">foldr1</span> functions work much like <span class="fixed">foldl</span> and <span class="fixed">foldr</span>, only you don't need to provide them with an explicit starting value. They assume the first (or last) element of the list to be the starting value and then start the fold with the element next to it. With that in mind, the <span class="fixed">sum</span> function can be implemented like so: <span class="fixed">sum = foldl1 (+)</span>. Because they depend on the lists they fold up having at least one element, they cause runtime errors if called with empty lists. <span class="fixed">foldl</span> and <span class="fixed">foldr</span>, on the other hand, work fine with empty lists. When making a fold, think about how it acts on an empty list. If the function doesn't make sense when given an empty list, you can probably use a <span class="fixed">foldl1</span> or <span class="fixed">foldr1</span> to implement it.</p>
<p>Just to show you how powerful folds are, we're going to implement a bunch of standard library functions by using folds:</p>
<pre name="code" class="haskell:hs" style="display: none;">maximum' :: (Ord a) =&gt; [a] -&gt; a
maximum' = foldr1 (\x acc -&gt; if x &gt; acc then x else acc)

reverse' :: [a] -&gt; [a]
reverse' = foldl (\acc x -&gt; x : acc) []

product' :: (Num a) =&gt; [a] -&gt; a
product' = foldr1 (*)

filter' :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
filter' p = foldr (\x acc -&gt; if p x then x : acc else acc) []

head' :: [a] -&gt; a
head' = foldr1 (\x _ -&gt; x)

last' :: [a] -&gt; a
last' = foldl1 (\_ x -&gt; x)
</pre>
<p><span class="fixed">head</span> is better implemented by pattern matching, but this just goes to show, you can still achieve it by using folds. Our <span class="fixed">reverse'</span> definition is pretty clever, I think. We take a starting value of an empty list and then approach our list from the left and just prepend to our accumulator. In the end, we build up a reversed list. <span class="fixed">\acc x -&gt; x : acc</span> kind of looks like the <span class="fixed">:</span> function, only the parameters are flipped. That's why we could have also written our reverse as <span class="fixed">foldl (flip (:)) []</span>. </p>
<p>Another way to picture right and left folds is like this: say we have a right fold and the binary function is <span class="fixed">f</span> and the starting value is <span class="fixed">z</span>. If we're right folding over the list <span class="fixed">[3,4,5,6]</span>, we're essentially doing this: <span class="fixed">f 3 (f 4 (f 5 (f 6 z)))</span>. <span class="fixed">f</span> is called with the last element in the list and the accumulator, that value is given as the accumulator to the next to last value and so on. If we take <span class="fixed">f</span> to be <span class="fixed">+</span> and the starting accumulator value to be <span class="fixed">0</span>, that's <span class="fixed">3 + (4 + (5 + (6 + 0)))</span>. Or if we write <span class="fixed">+</span> as a prefix function, that's <span class="fixed">(+) 3 ((+) 4 ((+) 5 ((+) 6 0)))</span>. Similarly, doing a left fold over that list with <span class="fixed">g</span> as the binary function and <span class="fixed">z</span> as the accumulator is the equivalent of <span class="fixed">g (g (g (g z 3) 4) 5) 6</span>. If we use <span class="fixed">flip (:)</span> as the binary function and <span class="fixed">[]</span> as the accumulator (so we're reversing the list), then that's the equivalent of <span class="fixed">flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6</span>. And sure enough, if you evaluate that expression, you get <span class="fixed">[6,5,4,3]</span>.</p>
<p><span class="function label">scanl</span> and <span class="function label">scanr</span> are like <span class="fixed">foldl</span> and <span class="fixed">foldr</span>, only they report all the intermediate accumulator states in the form of a list. There are also <span class="fixed">scanl1</span> and <span class="fixed">scanr1</span>, which are analogous to <span class="fixed">foldl1</span> and <span class="fixed">foldr1</span>.</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; scanl (+) 0 [3,5,2,1]
[0,3,8,10,11]
ghci&gt; scanr (+) 0 [3,5,2,1]
[11,8,3,1,0]
ghci&gt; scanl1 (\acc x -&gt; if x &gt; acc then x else acc) [3,4,5,3,7,9,2,1]
[3,4,5,5,7,9,9,9]
ghci&gt; scanl (flip (:)) [] [3,2,1]
[[],[3],[2,3],[1,2,3]]
</pre>
<p>When using a <span class="fixed">scanl</span>, the final result will be in the last element of the resulting list while a <span class="fixed">scanr</span> will place the result in the head.</p>
<p>Scans are used to monitor the progression of a function that can be implemented as a fold. Let's answer us this question: <em>How many elements does it take for the sum of the roots of all natural numbers to exceed 1000?</em> To get the squares of all natural numbers, we just do <span class="fixed">map sqrt [1..]</span>. Now, to get the sum, we could do a fold, but because we're interested in how the sum progresses, we're going to do a scan. Once we've done the scan, we just see how many sums are under 1000. The first sum in the scanlist will be 1, normally. The second will be 1 plus the square root of 2. The third will be that plus the square root of 3. If there are X sums under 1000, then it takes X+1 elements for the sum to exceed 1000.</p>
<pre name="code" class="haskell:hs" style="display: none;">sqrtSums :: Int
sqrtSums = length (takeWhile (&lt;1000) (scanl1 (+) (map sqrt [1..]))) + 1
</pre>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; sqrtSums
131
ghci&gt; sum (map sqrt [1..131])
1005.0942035344083
ghci&gt; sum (map sqrt [1..130])
993.6486803921487
</pre>
<p>We use <span class="fixed">takeWhile</span> here instead of <span class="fixed">filter</span> because <span class="fixed">filter</span> doesn't work on infinite lists. Even though we know the list is ascending, <span class="fixed">filter</span> doesn't, so we use <span class="fixed">takeWhile</span> to cut the scanlist off at the first occurence of a sum greater than 1000.</p>
<a name="function-application"></a><h2>Function application with $</h2>
<p>Alright, next up, we'll take a look at the <span class="fixed">$</span> function, also called <i>function application</i>. First of all, let's check out how it's defined:</p>
<pre name="code" class="haskell:hs" style="display: none;">($) :: (a -&gt; b) -&gt; a -&gt; b
f $ x = f x
</pre>
<img src="./files/dollar.png" alt="dollar" class="left" width="180" height="136">
<p>What the heck? What is this useless operator? It's just function application! Well, almost, but not quite! Whereas normal function application (putting a space between two things) has a really high precedence, the <span class="fixed">$</span> function has the lowest precedence. Function application with a space is left-associative (so <span class="fixed">f a b c</span> is the same as <span class="fixed">((f a) b) c)</span>), function application with <span class="fixed">$</span> is right-associative.</p>
<p>That's all very well, but how does this help us? Most of the time, it's a convenience function so that we don't have to write so many parentheses. Consider the expression <span class="fixed">sum (map sqrt [1..130])</span>. Because <span class="fixed">$</span> has such a low precedence, we can rewrite that expression as <span class="fixed">sum $ map sqrt [1..130]</span>, saving ourselves precious keystrokes! When a <span class="fixed">$</span> is encountered, the expression on its right is applied as the parameter to the function on its left. How about <span class="fixed">sqrt 3 + 4 + 9</span>? This adds together 9, 4 and the square root of 3. If we want get the square root of <i>3 + 4 + 9</i>, we'd have to write <span class="fixed">sqrt (3 + 4 + 9)</span> or if we use <span class="fixed">$</span> we can write it as <span class="fixed">sqrt $ 3 + 4 + 9</span> because <span class="fixed">$</span> has the lowest precedence of any operator. That's why you can imagine a <span class="fixed">$</span> being sort of the equivalent of writing an opening parentheses and then writing a closing one on the far right side of the expression.</p>
<p>How about <span class="fixed">sum (filter (&gt; 10) (map (*2) [2..10]))</span>? Well, because <span class="fixed">$</span> is right-associative, <span class="fixed">f (g (z x))</span> is equal to <span class="fixed">f $ g $ z x</span>. And so, we can rewrite <span class="fixed">sum (filter (&gt; 10) (map (*2) [2..10]))</span> as <span class="fixed">sum $ filter (&gt; 10) $ map (*2) [2..10]</span>. </p>
<p>But apart from getting rid of parentheses, <span class="fixed">$</span> means that function application can be treated just like another function. That way, we can, for instance, map function application over a list of functions.</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; map ($ 3) [(4+), (10*), (^2), sqrt]
[7.0,30.0,9.0,1.7320508075688772]
</pre>
<a name="composition"></a><h2>Function composition</h2>
<p>In mathematics, function composition is defined like this: <img src="./files/composition.png" alt=" (f . g)(x) = f(g(x))">, meaning that composing two functions produces a new function that, when called with a parameter, say, <i>x</i> is the equivalent of calling <i>g</i> with the parameter <i>x</i> and then calling the <i>f</i> with that result.</p>
<p>In Haskell, function composition is pretty much the same thing. We do function composition with the <span class="fixed">.</span> function, which is defined like so:</p>
<pre name="code" class="haskell:hs" style="display: none;">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
f . g = \x -&gt; f (g x)
</pre>
<img src="./files/notes.png" alt="notes" class="left" width="230" height="198">
<p>Mind the type declaration. <span class="fixed">f</span> must take as its parameter a value that has the same type as <span class="fixed">g</span>'s return value. So the resulting function takes a parameter of the same type that <span class="fixed">g</span> takes and returns a value of the same type that <span class="fixed">f</span> returns. The expression <span class="fixed">negate . (* 3)</span> returns a function that takes a number, multiplies it by 3 and then negates it.</p>
<p>One of the uses for function composition is making functions on the fly to pass to other functions. Sure, can use lambdas for that, but many times, function composition is clearer and more concise. Say we have a list of numbers and we want to turn them all into negative numbers. One way to do that would be to get each number's absolute value and then negate it, like so:</p>
<pre name="code" class="haskell:hs" style="display: none;">ghci&gt; map (\x -&gt; negate (abs x)) [5,-3,-6,7,-3,2,-19,24]
[-5,-3,-6,-7,-3,-2,-19,-24]
</pre>
<p>Notice the lambda and how it looks like the result function composition. Using function composition, we can rewrite that as:</p>
<pre name="code" class="haskell:hs" style="display: none;">ghci&gt; map (negate . abs) [5,-3,-6,7,-3,2,-19,24]
[-5,-3,-6,-7,-3,-2,-19,-24]
</pre>
<p>Fabulous! Function composition is right-associative, so we can compose many functions at a time. The expression <span class="fixed">f (g (z x))</span> is equivalent to <span class="fixed">(f . g . z) x</span>. With that in mind, we can turn</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; map (\xs -&gt; negate (sum (tail xs))) [[1..5],[3..6],[1..7]]
[-14,-15,-27]
</pre>
<p>into</p>
<pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; map (negate . sum . tail) [[1..5],[3..6],[1..7]]
[-14,-15,-27]
</pre>
<p>But what about functions that take several parameters? Well, if we want to use them in function composition, we usually have to partially apply them just so much that each function takes just one parameter. <span class="fixed"> sum (replicate 5 (max 6.7 8.9))</span> can be rewritten as <span class="fixed">(sum . replicate 5 . max 6.7) 8.9</span> or as <span class="fixed">sum . replicate 5 . max 6.7 $ 8.9</span>. What goes on in here is this: a function that takes what <span class="fixed">max 6.7</span> takes and applies <span class="fixed">replicate 5</span> to it is created. Then, a function that takes the result of that and does a sum of it is created. Finally, that function is called with <span class="fixed">8.9</span>. But normally, you just read that as: apply <span class="fixed">8.9</span> to <span class="fixed">max 6.7</span>, then apply <span class="fixed">replicate 5</span> to that and then apply <span class="fixed">sum</span> to that. If you want to rewrite an expression with a lot of parentheses by using function composition, you can start by putting the last parameter of the innermost function after a <span class="fixed">$</span> and then just composing all the other function calls, writing them without their last parameter and putting dots between them. If you have <span class="fixed">replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8])))</span>, you can write it as <span class="fixed">replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]</span>. If the expression ends with three parentheses, chances are that if you translate it into function composition, it'll have three composition operators.</p>
<p>Another common use of function composition is defining functions in the so-called point free style (also called the point<i>less</i> style). Take for example this function that we wrote earlier:</p>
<pre name="code" class="haskell:hs" style="display: none;">sum' :: (Num a) =&gt; [a] -&gt; a   
sum' xs = foldl (+) 0 xs   
</pre>
<p>The <span class="fixed">xs</span> is exposed on both right sides. Because of currying, we can omit the <span class="fixed">xs</span> on both sides, because calling <span class="fixed">foldl (+) 0</span> creates a function that takes a list. Writing the function as <span class="fixed">sum' = foldl (+) 0</span> is called writing it in point free style. How would we write this in point free style?</p>
<pre name="code" class="haskell:hs" style="display: none;">fn x = ceiling (negate (tan (cos (max 50 x))))
</pre>
<p>We can't just get rid of the <span class="fixed">x</span> on both right right sides. The <span class="fixed">x</span> in the function body has parentheses after it. <span class="fixed">cos (max 50)</span> wouldn't make sense. You can't get the cosine of a function. What we can do is express <span class="fixed">fn</span> as a composition of functions.</p>
<pre name="code" class="haskell:hs" style="display: none;">fn = ceiling . negate . tan . cos . max 50
</pre>
<p>Excellent! Many times, a point free style is more readable and concise, because it makes you think about functions and what kind of functions composing them results in instead of thinking about data and how it's shuffled around. You can take simple functions and use composition as glue to form more complex functions. However, many times, writing a function in point free style can be less readable if a function is too complex. That's why making long chains of function composition is discouraged, although I plead guilty of sometimes being too composition-happy. The prefered style is to use <i>let</i> bindings to give labels to intermediary results or split the problem into sub-problems and then put it together so that the function makes sense to someone reading it instead of just making a huge composition chain.</p>
<p>In the section about maps and filters, we solved a problem of finding the sum of all odd squares that are smaller than 10,000. Here's what the solution looks like when put into a function.</p>
<pre name="code" class="haskell:hs" style="display: none;">oddSquareSum :: Integer
oddSquareSum = sum (takeWhile (&lt;10000) (filter odd (map (^2) [1..])))   
</pre>
<p>Being such a fan of function composition, I would have probably written that like this:</p>
<pre name="code" class="haskell:hs" style="display: none;">oddSquareSum :: Integer
oddSquareSum = sum . takeWhile (&lt;10000) . filter odd . map (^2) $ [1..]
</pre>
<p>However, if there was a chance of someone else reading that code, I would have written it like this:</p>
<pre name="code" class="haskell:hs" style="display: none;">oddSquareSum :: Integer
oddSquareSum = 
    let oddSquares = filter odd $ map (^2) [1..]
        belowLimit = takeWhile (&lt;10000) oddSquares
    in  sum belowLimit
</pre>
<p>It wouldn't win any code golf competition, but someone reading the function will probably find it easier to read than a composition chain.</p>
                <div class="footdiv">
                <ul>
                    <li style="text-align:left">
                                                        <a href="http://learnyouahaskell.com/recursion" class="prevlink">Recursion</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="http://learnyouahaskell.com/chapters">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="http://learnyouahaskell.com/modules" class="nxtlink">Modules</a>
                                            </li>
                </ul>
            </div>
        </div>
    <script type="text/javascript" src="./files/shCore.js"></script>
    <script type="text/javascript" src="./files/shBrushHaskell.js"></script>
    <script type="text/javascript" src="./files/shBrushPlain.js"></script>
    <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script><script src="./files/ga.js" type="text/javascript"></script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script>


</body></html>